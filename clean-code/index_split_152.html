<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <title>index</title>
    <meta name="generator" content="pdftohtml 0.36"/>
    <meta name="date" content="2009-10-16T23:21:09+00:00"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="calibre">
<h2 class="calibre5" id="calibre_pb_302">Chapter 17: Smells and Heuristics</h2>
<p class="calibre1"><a href="index_split_000.html#p17"><b class="calibre3">T5:  <i class="calibre4">Test Boundary Conditions</i></b></a></p>
<p class="calibre1">Take special care to test boundary conditions. We often get the middle of an algorithm right but misjudge the boundaries.</p>
<p class="calibre1"><a href="index_split_000.html#p17"><b class="calibre3">T6:  <i class="calibre4">Exhaustively Test Near Bugs</i></b></a></p>
<p class="calibre1">Bugs tend to congregate. When you find a bug in a function, it is wise to do an exhaustive test of that function. You’ll probably find that the bug was not alone.</p>
<p class="calibre1"><a href="index_split_000.html#p17"><b class="calibre3">T7:  <i class="calibre4">Patterns of Failure Are Revealing</i></b></a></p>
<p class="calibre1">Sometimes you can diagnose a problem by finding patterns in the way the test cases fail.</p>
<p class="calibre1">This is another argument for making the test cases as complete as possible. Complete test cases, ordered in a reasonable way, expose patterns.</p>
<p class="calibre1">As a simple example, suppose you noticed that all tests with an input larger than five characters failed? Or what if any test that passed a negative number into the second argument of a function failed? Sometimes just seeing the pattern of red and green on the test report is enough to spark the “Aha!” that leads to the solution. Look back at page 267 to see an interesting example of this in the SerialDate example.</p>
<p class="calibre1"><a href="index_split_000.html#p17"><b class="calibre3">T8:  <i class="calibre4">Test Coverage Patterns Can Be Revealing</i></b></a></p>
<p class="calibre1">Looking at the code that is or is not executed by the passing tests gives clues to why the failing tests fail.</p>
<p class="calibre1"><a href="index_split_000.html#p17"><b class="calibre3">T9:  <i class="calibre4">Tests Should Be Fast</i></b></a></p>
<p class="calibre1">A slow test is a test that won’t get run. When things get tight, it’s the slow tests that will be dropped from the suite. So  <i class="calibre4">do what you must </i> to keep your tests fast.</p>
<p class="calibre1"><a href="index_split_000.html#p17"><b class="calibre3">Conclusion</b></a></p>
<p class="calibre1">This list of heuristics and smells could hardly be said to be complete. Indeed, I’m not sure that such a list can  <i class="calibre4">ever </i> be complete. But perhaps completeness should not be the goal, because what this list  <i class="calibre4">does</i> do is imply a value system.</p>
<p class="calibre1">Indeed, that value system has been the goal, and the topic, of this book. Clean code is not written by following a set of rules. You don’t become a software craftsman by learning a list of heuristics. Professionalism and craftsmanship come from values that drive disciplines.</p>
<p class="calibre1"><a id="p346"></a><b class="calibre3">Bibliography</b></p>
<p class="calibre1">315</p>
<p class="calibre1"><a href="index_split_000.html#p17"><b class="calibre3">Bibliography</b></a></p>
<p class="calibre1"><b class="calibre3">[Refactoring]:  </b> <i class="calibre4">Refactoring: Improving the Design of Existing Code</i>, Martin Fowler et al., Addison-Wesley, 1999.</p>
<p class="calibre1"><b class="calibre3">[PRAG]:  </b> <i class="calibre4">The Pragmatic Programmer</i>, Andrew Hunt, Dave Thomas, Addison-Wesley, 2000.</p>
<p class="calibre1"><b class="calibre3">[GOF]:  </b> <i class="calibre4">Design Patterns: Elements of Reusable Object Oriented Software</i>, Gamma et al., Addison-Wesley, 1996.</p>
<p class="calibre1"><b class="calibre3">[Beck97]:  </b> <i class="calibre4">Smalltalk Best Practice Patterns</i>, Kent Beck, Prentice Hall, 1997.</p>
<p class="calibre1"><b class="calibre3">[Beck07]:  </b> <i class="calibre4">Implementation Patterns</i>, Kent Beck, Addison-Wesley, 2008.</p>
<p class="calibre1"><b class="calibre3">[PPP]:  </b> <i class="calibre4">Agile Software Development: Principles, Patterns, and Practices</i>, Robert C. Martin, Prentice Hall, 2002.</p>
<p class="calibre1"><b class="calibre3">[DDD]:  </b> <i class="calibre4">Domain Driven Design</i>, Eric Evans, Addison-Wesley, 2003.</p>
<p class="calibre1"><a id="p347"></a> <i class="calibre4">This page intentionally left blank </i></p>
<p class="calibre1"><a id="p348"></a><a href="index_split_000.html#p17"><b class="calibre3">Appendix A</b></a></p>
<p class="calibre1"><a href="index_split_000.html#p17"><b class="calibre3">Concurrency II</b></a></p>
<p class="calibre1">by Brett L. Schuchert</p>
<p class="calibre1">This appendix supports and amplifies the  <i class="calibre4">Concurrency</i> chapter on page 177. It is written as a series of independent topics and you can generally read them in any order. There is some duplication between sections to allow for such reading.</p>
<p class="calibre1"><a href="index_split_000.html#p17"><b class="calibre3">Client/Server Example</b></a></p>
<p class="calibre1">Imagine a simple client/server application. A server sits and waits listening on a socket for a client to connect. A client connects and sends a request.</p>
<p class="calibre1"><a href="index_split_000.html#p17"><b class="calibre3">The Server</b></a></p>
<p class="calibre1">Here is a simplified version of a server application. Full source for this example is available starting on page 343,  <i class="calibre4">Client/Server Nonthreaded</i>.</p>
<p class="calibre1">ServerSocket serverSocket = new ServerSocket(8009);</p>
<p class="calibre1">while (keepProcessing) {</p>
<p class="calibre1">try {</p>
<p class="calibre1">Socket socket = serverSocket.accept();</p>
<p class="calibre1">process(socket);</p>
<p class="calibre1">} catch (Exception e) {</p>
<p class="calibre1">handle(e);</p>
<p class="calibre1">}</p>
<p class="calibre1">}</p>
<p class="calibre1">317</p>
<p class="calibre1"><a id="p349"></a>318</p>
<p class="calibre1"><b class="calibre3">Appendix A: Concurrency II</b></p>
<p class="calibre1">This simple application waits for a connection, processes an incoming message, and then again waits for the next client request to come in. Here’s client code that connects to this server:</p>
<p class="calibre1">private void connectSendReceive(int i) {</p>
<p class="calibre1">try {</p>
<p class="calibre1">Socket socket = new Socket("localhost", PORT);</p>
<p class="calibre1">MessageUtils.sendMessage(socket, Integer.toString(i));</p>
<p class="calibre1">MessageUtils.getMessage(socket);</p>
<p class="calibre1">socket.close();</p>
<p class="calibre1">} catch (Exception e) {</p>
<p class="calibre1">e.printStackTrace();</p>
<p class="calibre1">}</p>
<p class="calibre1">}</p>
<p class="calibre1">How well does this client/server pair perform? How can we formally describe that performance? Here’s a test that asserts that the performance is “acceptable”:</p>
<p class="calibre1">@Test(timeout = 10000)</p>
<p class="calibre1">public void shouldRunInUnder10Seconds() throws Exception {</p>
<p class="calibre1">Thread[] threads = createThreads();</p>
<p class="calibre1">startAllThreadsw(threads);</p>
<p class="calibre1">waitForAllThreadsToFinish(threads);</p>
<p class="calibre1">}</p>
<p class="calibre1">The setup is left out to keep the example simple (see “ClientTest.java” on page 344). This test asserts that it should complete within 10,000 milliseconds.</p>
<p class="calibre1">This is a classic example of validating the throughput of a system. This system should complete a series of client requests in ten seconds. So long as the server can process each individual client request in time, the test will pass.</p>
<p class="calibre1">What happens if the test fails? Short of developing some kind of event polling loop, there is not much to do within a single thread that will make this code any faster. Will using multiple threads solve the problem? It might, but we need to know where the time is being spent. There are two possibilities: <b class="calibre3">• </b>I/O—using a socket, connecting to a database, waiting for virtual memory swapping, and so on.</p>
<p class="calibre1"><b class="calibre3">• </b>Processor—numerical calculations, regular expression processing, garbage collection, and so on.</p>
<p class="calibre1">Systems typically have some of each, but for a given operation one tends to dominate. If the code is processor bound, more processing hardware can improve throughput, making our test pass. But there are only so many CPU cycles available, so adding threads to a processor-bound problem will not make it go faster.</p>
<p class="calibre1">On the other hand, if the process is I/O bound, then concurrency can increase efficiency. When one part of the system is waiting for I/O, another part can use that wait time to process something else, making more effective use of the available CPU.</p>
<p class="calibre1"><a id="p350"></a><b class="calibre3">Client/Server Example</b></p>
<p class="calibre1">319</p>
<p class="calibre1"><a href="index_split_000.html#p17"><b class="calibre3">Adding Threading</b></a></p>
<p class="calibre1">Assume for the moment that the performance test fails. How can we improve the throughput so that the performance test passes? If the process method of the server is I/O bound, then here is one way to make the server use threads (just change the processMessage): void process(final Socket socket) {</p>
<p class="calibre1">if (socket == null)</p>
<p class="calibre1">return;</p>
<p class="calibre1">Runnable clientHandler = new Runnable() {</p>
<p class="calibre1">public void run() {</p>
<p class="calibre1">try {</p>
<p class="calibre1">String message = MessageUtils.getMessage(socket);</p>
<p class="calibre1">MessageUtils.sendMessage(socket, "Processed: " + message); closeIgnoringException(socket);</p>
<p class="calibre1">} catch (Exception e) {</p>
<p class="calibre1">e.printStackTrace();</p>
<p class="calibre1">}</p>
<p class="calibre1">}</p>
<p class="calibre1">};</p>
<p class="calibre1">Thread clientConnection = new Thread(clientHandler);</p>
<p class="calibre1">clientConnection.start();</p>
<p class="calibre1">}</p>
<p class="calibre1">Assume that this change causes the test to pass;1 the code is complete, correct?</p>
<p class="calibre1"><a href="index_split_000.html#p17"><b class="calibre3">Server Observations</b></a></p>
<p class="calibre1">The updated server completes the test successfully in just over one second. Unfortunately, this solution is a bit naive and introduces some new problems.</p>
<p class="calibre1">How many threads might our server create? The code sets no limit, so the we could feasibly hit the limit imposed by the Java Virtual Machine (JVM). For many simple systems this may suffice. But what if the system is meant to support many users on the public net? If too many users connect at the same time, the system might grind to a halt.</p>
<p class="calibre1">But set the behavioral problem aside for the moment. The solution shown has problems of cleanliness and structure. How many responsibilities does the server code have?</p>
<p class="calibre1"><b class="calibre3">• </b>Socket connection management</p>
<p class="calibre1"><b class="calibre3">• </b>Client processing</p>
<p class="calibre1"><b class="calibre3">• </b>Threading policy</p>
<p class="calibre1"><b class="calibre3">• </b>Server shutdown policy</p>
<p class="calibre1">Unfortunately, all these responsibilities live in the process function. In addition, the code crosses many different levels of abstraction. So, small as the process function is, it needs to be repartitioned.</p>
<p class="calibre1">1.</p>
<p class="calibre1">You can verify that for yourself by trying out the before and after code. Review the nonthreaded code starting on page 343.</p>
<p class="calibre1">Review the threaded code starting on page 346.</p>
<p class="calibre1"><a id="p351"></a>320</p>
<p class="calibre1"><b class="calibre3">Appendix A: Concurrency II</b></p>
<p class="calibre1">The server has several reasons to change; therefore it violates the Single Responsibility Principle. To keep concurrent systems clean, thread management should be kept to a few, well-controlled places. What’s more, any code that manages threads should do nothing other than thread management. Why? If for no other reason than that tracking down concurrency issues is hard enough without having to unwind other nonconcurrency issues at the same time.</p>
<p class="calibre1">If we create a separate class for each of the responsibilities listed above, including the thread management responsibility, then when we change the thread management strategy, the change will impact less overall code and will not pollute the other responsibilities. This also makes it much easier to test all the other responsibilities without having to worry about threading. Here is an updated version that does just that: public void run() {</p>
<p class="calibre1">while (keepProcessing) {</p>
<p class="calibre1">try {</p>
<p class="calibre1">ClientConnection clientConnection = connectionManager.awaitClient(); ClientRequestProcessor requestProcessor</p>
<p class="calibre1">= new ClientRequestProcessor(clientConnection);</p>
<p class="calibre1">clientScheduler.schedule(requestProcessor);</p>
<p class="calibre1">} catch (Exception e) {</p>
<p class="calibre1">e.printStackTrace();</p>
<p class="calibre1">}</p>
<p class="calibre1">}</p>
<p class="calibre1">connectionManager.shutdown();</p>
<p class="calibre1">}</p>
<p class="calibre1">This now focuses all things thread-related into one place, clientScheduler. If there are concurrency problems, there is just one place to look:</p>
<p class="calibre1">public interface ClientScheduler {</p>
<p class="calibre1">void schedule(ClientRequestProcessor requestProcessor);</p>
<p class="calibre1">}</p>
<p class="calibre1">The current policy is easy to implement:</p>
<p class="calibre1">public class ThreadPerRequestScheduler implements ClientScheduler {</p>
<p class="calibre1">public void schedule(final ClientRequestProcessor requestProcessor) {</p>
<p class="calibre1">Runnable runnable = new Runnable() {</p>
<p class="calibre1">public void run() {</p>
<p class="calibre1">requestProcessor.process();</p>
<p class="calibre1">}</p>
<p class="calibre1">};</p>
<p class="calibre1">Thread thread = new Thread(runnable);</p>
<p class="calibre1">thread.start();</p>
<p class="calibre1">}</p>
<p class="calibre1">}</p>
<p class="calibre1">Having isolated all the thread management into a single place, it is much easier to change the way we control threads. For example, moving to the Java 5 Executor framework involves writing a new class and plugging it in (Listing A-1).</p>
<p class="calibre1"><a id="p352"></a><b class="calibre3">Possible Paths of Execution</b></p>
<p class="calibre1">321</p>
<p class="calibre1"><b class="calibre3">Listing A-1 </b></p>
<p class="calibre1"><b class="calibre3">ExecutorClientScheduler.java</b></p>
<p class="calibre1">import java.util.concurrent.Executor;</p>
<p class="calibre1">import java.util.concurrent.Executors;</p>
<p class="calibre1">public class ExecutorClientScheduler implements ClientScheduler {</p>
<p class="calibre1">Executor executor;</p>
<p class="calibre1">public ExecutorClientScheduler(int availableThreads) {</p>
<p class="calibre1">executor = Executors.newFixedThreadPool(availableThreads);</p>
<p class="calibre1">}</p>
<p class="calibre1">public void schedule(final ClientRequestProcessor requestProcessor) {</p>
<p class="calibre1">Runnable runnable = new Runnable() {</p>
<p class="calibre1">public void run() {</p>
<p class="calibre1">requestProcessor.process();</p>
<p class="calibre1">}</p>
<p class="calibre1">};</p>
<p class="calibre1">executor.execute(runnable);</p>
<p class="calibre1">}</p>
<p class="calibre1">}</p>
<p class="calibre1"><a href="index_split_000.html#p17"><b class="calibre3">Conclusion</b></a></p>
<p class="calibre1">Introducing concurrency in this particular example demonstrates a way to improve the throughput of a system and one way of validating that throughput through a testing framework. Focusing all concurrency code into a small number of classes is an example of applying the Single Responsibility Principle. In the case of concurrent programming, this becomes especially important because of its complexity.</p>
<p class="calibre1"><a href="index_split_000.html#p17"><b class="calibre3">Possible Paths of Execution</b></a></p>
<p class="calibre1">Review the method incrementValue, a one-line Java method with no looping or branching: public class IdGenerator {</p>
<p class="calibre1">int lastIdUsed;</p>
<p class="calibre1">public int incrementValue() {</p>
<p class="calibre1">return ++lastIdUsed;</p>
<p class="calibre1">}</p>
<p class="calibre1">}</p>
<p class="calibre1">Ignore integer overflow and assume that only one thread has access to a single instance of IdGenerator. In this case there is a single path of execution and a single guaranteed result:</p>
<p class="calibre1"><b class="calibre3">• </b>The value returned is equal to the value of lastIdUsed, both of which are one greater than just before calling the method.</p>
<p class="calibre1"><a id="p353"></a>322</p>
<p class="calibre1"><b class="calibre3">Appendix A: Concurrency II</b></p>
<p class="calibre1">What happens if we use two threads and leave the method unchanged? What are the possible outcomes if each thread calls incrementValue once? How many possible paths of execution are there? First, the outcomes (assume lastIdUsed starts with a value of 93): <b class="calibre3">• </b>Thread 1 gets the value of 94, thread 2 gets the value of 95, and lastIdUsed is now 95.</p>
<p class="calibre1"><b class="calibre3">• </b>Thread 1 gets the value of 95, thread 2 gets the value of 94, and lastIdUsed is now 95.</p>
<p class="calibre1"><b class="calibre3">• </b>Thread 1 gets the value of 94, thread 2 gets the value of 94, and lastIdUsed is now 94.</p>
<p class="calibre1">The final result, while surprising, is possible. To see how these different results are possible, we need to understand the number of possible paths of execution and how the Java Virtual Machine executes them.</p>
<p class="calibre1"><a href="index_split_000.html#p17"><b class="calibre3">Number of Paths</b></a></p>
<p class="calibre1">To calculate the number of possible execution paths, we’ll start with the generated byte-code. The one line of java (return ++lastIdUsed;) becomes eight byte-code instructions. It is possible for the two threads to interleave the execution of these eight instructions the way a card dealer interleaves cards as he shuffles a deck.2 Even with only eight cards in each hand, there are a remarkable number of shuffled outcomes.</p>
<p class="calibre1">For this simple case of  <i class="calibre4">N</i> instructions in a sequence, no looping or conditionals, and  <i class="calibre4">T</i></p>
<p class="calibre1">threads, the total number of possible execution paths is equal to ( <i class="calibre4">NT</i>)!</p>
<p class="calibre1">--------------</p>
<p class="calibre1"><i class="calibre4">T</i></p>
<p class="calibre1"><i class="calibre4">N</i>!</p>
<p class="calibre1"><b class="calibre3">Calculating the Possible Orderings </b></p>
<p class="calibre1">This comes from an email from Uncle Bob to Brett:</p>
<p class="calibre1">With  <i class="calibre4">N</i> steps and  <i class="calibre4">T</i> threads there are  <i class="calibre4">T</i> *  <i class="calibre4">N</i> total steps. Prior to each step there is a context switch that chooses between the  <i class="calibre4">T</i> threads. Each path can thus be represented as a string of digits denoting the context switches.</p>
<p class="calibre1">Given steps A and B and threads 1 and 2, the six possible paths are 1122, 1212, 1221, 2112, 2121, and 2211. Or, in terms of steps it is A1B1A2B2, A1A2B1B2, A1A2B2B1, A2A1B1B2, A2A1B2B1, and A2B2A1B1. For</p>
<p class="calibre1">three threads the sequence is 112233, 112323, 113223, 113232, 112233, 121233, 121323, 121332, 123132, 123123, . . . .</p>
<p class="calibre1">One characteristic of these strings is that there must always be  <i class="calibre4">N</i></p>
<p class="calibre1">instances of each  <i class="calibre4">T</i>. So the string 111111 is invalid because it has six instances of 1 and zero instances of 2 and 3.</p>
<p class="calibre1">2.</p>
<p class="calibre1">This is a bit of a simplification. However, for the purpose of this discussion, we can use this simplifying model.</p>
<p class="calibre1"><a id="p354"></a><b class="calibre3">Possible Paths of Execution</b></p>
<p class="calibre1">323</p>
<p class="calibre1"><b class="calibre3">Calculating the Possible Orderings (continued)</b></p>
<p class="calibre1">So we want the permutations of  <i class="calibre4">N</i> 1’s,  <i class="calibre4">N</i>  2’s,  . . . and   <i class="calibre4">N</i>  <i class="calibre4">T’</i> s. This is really just the permutations of  <i class="calibre4">N</i> *  <i class="calibre4">T</i> things taken  <i class="calibre4">N</i> *  <i class="calibre4">T</i> at a time, which is ( <i class="calibre4">N</i> *  <i class="calibre4">T </i>)!, but with all the duplicates removed. So the trick is to count the duplicates and subtract that from ( <i class="calibre4">N</i> *  <i class="calibre4">T</i> )!.</p>
<p class="calibre1">Given two steps and two threads, how many duplicates are there? Each four-digit string has two 1s and two 2s. Each of those pairs could be swapped without changing the sense of the string. You could swap the 1s or the 2s both, or neither. So there are four isomorphs for each string, which means that there are three duplicates. So three out of four of the options are duplicates; alternatively one of four of the permutations are NOT duplicates. 4! * .25 = 6.  So this reasoning seems to work.</p>
<p class="calibre1">How many duplicates are there? In the case where  <i class="calibre4">N</i> = 2 and  <i class="calibre4">T</i> = 2, I could swap the 1s, the 2s, or both. In the case where  <i class="calibre4">N</i> = 2  and  <i class="calibre4">T</i> = 3,  I could swap the 1s, the 2s, the 3s, 1s and 2s, 1s and 3s, or 2s and 3s. Swapping is just the permutations of  <i class="calibre4">N</i>. Let’s say there are  <i class="calibre4">P</i> permutations of  <i class="calibre4">N</i>.</p>
<p class="calibre1">The number of different ways to arrange those permutations are  <i class="calibre4">P</i>** <i class="calibre4">T</i>.</p>
<p class="calibre1">So the number of possible isomorphs is  <i class="calibre4">N</i>!** <i class="calibre4">T</i>. And so the number of paths is ( <i class="calibre4">T</i>* <i class="calibre4">N</i>)!/( <i class="calibre4">N</i>!** <i class="calibre4">T</i>). Again, in our  <i class="calibre4">T</i> = 2,  <i class="calibre4">N</i> = 2 case we get 6 (24/4).</p>
<p class="calibre1">For  <i class="calibre4">N</i> = 2 and  <i class="calibre4">T</i> = 3 we get 720/8 = 90.</p>
<p class="calibre1">For  <i class="calibre4">N</i> = 3 and  <i class="calibre4">T</i> = 3 we get 9!/6^3 = 1680.</p>
<p class="calibre1">For our simple case of one line of Java code, which equates to eight lines of byte-code and two threads, the total number of possible paths of execution is 12,870. If the type of lastIdUsed is a long, then every read/write becomes two operations instead of one, and the number of possible orderings becomes 2,704,156.</p>
<p class="calibre1">What happens if we make one change to this method?</p>
<p class="calibre1">public <b class="calibre3">synchronized</b> void incrementValue() {</p>
<p class="calibre1">++lastIdUsed;</p>
<p class="calibre1">}</p>
<p class="calibre1">The number of possible execution pathways becomes two for two threads and N! in the general case.</p>
<p class="calibre1"><a href="index_split_000.html#p17"><b class="calibre3">Digging Deeper</b></a></p>
<p class="calibre1">What about the surprising result that two threads could both call the method once (before we added synchronized) and get the same numeric result? How is that possible? First things first.</p>
<p class="calibre1">What is an atomic operation? We can define an atomic operation as any operation that is uninterruptable. For example, in the following code, line 5, where 0 is assigned to lastid, is atomic because according to the Java Memory model, assignment to a 32-bit value is uninterruptable.</p>
<p class="calibre1"><a id="p355"></a>324</p>
<p class="calibre1"><b class="calibre3">Appendix A: Concurrency II</b></p>
<p class="calibre1">01: public class Example {</p>
<p class="calibre1">02:    int lastId;</p>
<p class="calibre1">03:</p>
<p class="calibre1">04:    public void resetId() {</p>
<p class="calibre1">05:        value = 0;</p>
<p class="calibre1">06:    }</p>
<p class="calibre1">07:</p>
<p class="calibre1">08:    public int getNextId() {</p>
<p class="calibre1">09:        ++value;</p>
<p class="calibre1">10:    }</p>
<p class="calibre1">11:}</p>
<p class="calibre1">What happens if we change type of lastId from int to long? Is line 5 still atomic?</p>
<p class="calibre1">Not according to the JVM specification. It could be atomic on a particular processor, but according to the JVM specification, assignment to any 64-bit value requires two 32-bit assignments. This means that between the first 32-bit assignment and the second 32-bit assignment, some other thread could sneak in and change one of the values.</p>
<p class="calibre1">What about the pre-increment operator, ++, on line 9? The pre-increment operator can be interrupted, so it is not atomic. To understand, let’s review the byte-code of both of these methods in detail.</p>
<p class="calibre1">Before we go any further, here are three definitions that will be important:</p>
<p class="calibre1"><b class="calibre3">• </b>Frame—Every method invocation requires a frame. The frame includes the return address, any parameters passed into the method and the local variables defined in the method. This is a standard technique used to define a call stack, which is used by modern languages to allow for basic function/method invocation and to allow for recursive invocation.</p>
<p class="calibre1"><b class="calibre3">• </b>Local variable—Any variables defined in the scope of the method. All nonstatic methods have at least one variable, <b class="calibre3">this</b>, which represents the current object, the object that received the most recent message (in the current thread), which caused the method invocation.</p>
<p class="calibre1"><b class="calibre3">• </b>Operand stack—Many of the instructions in the Java Virtual Machine take parameters. The operand stack is where those parameters are put. The stack is a standard last-in, first-out (LIFO) data structure.</p>
<p class="calibre1">Here is the byte-code generated for resetId():</p>
<p class="calibre1"><b class="calibre3">Mnemonic</b></p>
<p class="calibre1"><b class="calibre3">Description</b></p>
<p class="calibre1"><b class="calibre3">Operand </b></p>
<p class="calibre1"><b class="calibre3">Stack After</b></p>
<p class="calibre1">ALOAD 0</p>
<p class="calibre1">Load the 0th variable onto the operand stack.</p>
<p class="calibre1">this</p>
<p class="calibre1">What is the 0th variable? It is <b class="calibre3">this</b>., the current</p>
<p class="calibre1">object. When the method was called, the</p>
<p class="calibre1">receiver of the message, an instance of Example,</p>
<p class="calibre1">was pushed into the local variable array of the</p>
<p class="calibre1">frame created for method invocation. This is</p>
<p class="calibre1">always the first variable put in every instance</p>
<p class="calibre1">method.</p>
<p class="calibre1"><a id="p356"></a><b class="calibre3">Possible Paths of Execution</b></p>
<p class="calibre1">325</p>
<p class="calibre1"><b class="calibre3">Mnemonic</b></p>
<p class="calibre1"><b class="calibre3">Description</b></p>
<p class="calibre1"><b class="calibre3">Operand </b></p>
<p class="calibre1"><b class="calibre3">Stack After</b></p>
<p class="calibre1">ICONST_0</p>
<p class="calibre1">Put the constant value 0 onto the operand stack.</p>
<p class="calibre1">this, 0</p>
<p class="calibre1">PUTFIELD lastId</p>
<p class="calibre1">Store the top value on the stack (which is 0) into</p>
<p class="calibre1">&lt;empty&gt;</p>
<p class="calibre1">the field value of the object referred to by the</p>
<p class="calibre1">object reference one away from the top of the</p>
<p class="calibre1">stack, <b class="calibre3">this</b>.</p>
<p class="calibre1">These three instructions are guaranteed to be atomic because, although the thread executing them could be interrupted after any one of them, the information for the PUTFIELD instruction (the constant value 0 on the top of the stack and the reference to this one below the top, along with the field value) cannot be touched by another thread.</p>
<p class="calibre1">So when the assignment occurs, we are guaranteed that the value 0 will be stored in the field value. The operation is atomic. The operands all deal with information local to the method, so there is no interference between multiple threads.</p>
<p class="calibre1">So if these three instructions are executed by ten threads, there are 4.38679733629e+24</p>
<p class="calibre1">possible orderings. However, there is only one possible outcome, so the different orderings are irrelevant. It just so happens that the same outcome is guaranteed for longs in this case as well. Why? All ten threads are assigning a constant value. Even if they interleave with each other, the end result is the same.</p>
<p class="calibre1">With the ++ operation in the getNextId method, there are going to be problems.</p>
<p class="calibre1">Assume that lastId holds 42 at the beginning of this method. Here is the byte-code for this new method:</p>
<p class="calibre1"><b class="calibre3">Mnemonic</b></p>
<p class="calibre1"><b class="calibre3">Description</b></p>
<p class="calibre1"><b class="calibre3">Operand </b></p>
<p class="calibre1"><b class="calibre3">Stack After</b></p>
<p class="calibre1">ALOAD 0</p>
<p class="calibre1">Load this onto the operand stack</p>
<p class="calibre1">this</p>
<p class="calibre1">DUP</p>
<p class="calibre1">Copy the top of the stack. We now have two</p>
<p class="calibre1">this, this</p>
<p class="calibre1">copies of this on the operand stack.</p>
<p class="calibre1">GETFIELD lastId</p>
<p class="calibre1">Retrieve the value of the field lastId from the</p>
<p class="calibre1">this, 42</p>
<p class="calibre1">object pointed to on the top of the stack (this) and</p>
<p class="calibre1">store that value back on to the stack.</p>
<p class="calibre1">ICONST_1</p>
<p class="calibre1">Push the integer constant 1 on the stack.</p>
<p class="calibre1">this, 42, 1</p>
<p class="calibre1">IADD</p>
<p class="calibre1">Integer add the top two values on the operand</p>
<p class="calibre1">this, 43</p>
<p class="calibre1">stack and store the result back on to the operand</p>
<p class="calibre1">stack.</p>
<p class="calibre1">DUP_X1</p>
<p class="calibre1">Duplicate the value 43 and put it before this.</p>
<p class="calibre1">43, this, 43</p>
<p class="calibre1">PUTFIELD value</p>
<p class="calibre1">Store the top value on the operand stack, 43, into</p>
<p class="calibre1">43</p>
<p class="calibre1">the field value of the current object, represented by</p>
<p class="calibre1">the next-to-top value on the operand stack, this.</p>
<p class="calibre1">IRETURN</p>
<p class="calibre1">return the top (and only) value on the stack.</p>
<p class="calibre1">&lt;empty&gt;</p>
<p class="calibre1"><a id="p357"></a>326</p>
<p class="calibre1"><b class="calibre3">Appendix A: Concurrency II</b></p>
<p class="calibre1">Imagine the case where the first thread completes the first three instructions, up to and including GETFIELD, and then it is interrupted. A second thread takes over and performs the entire method, incrementing lastId by one; it gets 43 back. Then the first thread picks up where it left off; 42 is still on the operand stack because that was the value of lastId when it executed GETFIELD. It adds one to get 43 again and stores the result. The value 43 is returned to the first thread as well. The result is that one of the increments is lost because the first thread stepped on the second thread after the second thread interrupted the first thread.</p>
<p class="calibre1">Making the getNexId() method synchronized fixes this problem.</p>
<p class="calibre1"><a href="index_split_000.html#p17"><b class="calibre3">Conclusion</b></a></p>
<p class="calibre1">An intimate understanding of byte-code is not necessary to understand how threads can step on each other. If you can understand this one example, it should demonstrate the possibility of multiple threads stepping on each other, which is enough knowledge.</p>
<p class="calibre1">That being said, what this trivial example demonstrates is a need to understand the memory model enough to know what is and is not safe. It is a common misconception that the ++ (pre- or post-increment) operator is atomic, and it clearly is not. This means you need to know: <b class="calibre3">• </b>Where there are shared objects/values</p>
<p class="calibre1"><b class="calibre3">• </b>The code that can cause concurrent read/update issues</p>
<p class="calibre1"><b class="calibre3">• </b>How to guard such concurrent issues from happening</p>
<p class="calibre1"><a href="index_split_000.html#p17"><b class="calibre3">Knowing Your  Library</b></a></p>
<p class="calibre1"><a href="index_split_000.html#p17"><b class="calibre3">Executor Framework</b></a></p>
<p class="calibre1">As demonstrated in the ExecutorClientScheduler.java on page 321, the Executor framework introduced in Java 5 allows for sophisticated execution using thread pools. This is a class in the java.util.concurrent package.</p>
<p class="calibre1">If you are creating threads and are not using a thread pool or  <i class="calibre4">are</i> using a hand-written one, you should consider using the Executor. It will make your code cleaner, easier to follow, and smaller.</p>
<p class="calibre1">The Executor framework will pool threads, resize automatically, and recreate threads if necessary. It also supports  <i class="calibre4">futures, </i> a common concurrent programming construct. The Executor framework works with classes that implement Runnable and also works with classes that implement the Callable interface. A Callable looks like a Runnable, but it can return a result, which is a common need in multithreaded solutions.</p>
<p class="calibre1">A  <i class="calibre4">future</i> is handy when code needs to execute multiple, independent operations and wait for both to finish:</p>
<p class="calibre1">public String processRequest(String message) throws Exception {</p>
<p class="calibre1">Callable&lt;String&gt; makeExternalCall = new Callable&lt;String&gt;() {</p>
<p class="calibre1"><a id="p358"></a><b class="calibre3">Knowing Your  Library</b></p>
<p class="calibre1">327</p>
<p class="calibre1">public String call() throws Exception {</p>
<p class="calibre1">String result = "";</p>
<p class="calibre1">// make external request</p>
<p class="calibre1">return result;</p>
<p class="calibre1">}</p>
<p class="calibre1">};</p>
<p class="calibre1">Future&lt;String&gt; result = executorService.submit(makeExternalCall); String partialResult = doSomeLocalProcessing();</p>
<p class="calibre1">return result.get() + partialResult;</p>
<p class="calibre1">}</p>
<p class="calibre1">In this example, the method starts executing the makeExternalCall object. The method continues other processing. The final line calls result.get(), which blocks until the future completes.</p>
<p class="calibre1"><a href="index_split_000.html#p17"><b class="calibre3">Nonblocking Solutions</b></a></p>
<p class="calibre1">The Java 5 VM takes advantage of modern processor design, which supports reliable, nonblocking updates. Consider, for example, a class that uses synchronization (and therefore blocking) to provide a thread-safe update of a value: public class ObjectWithValue {</p>
<p class="calibre1">private int value;</p>
<p class="calibre1">public void synchronized incrementValue() { ++value; }</p>
<p class="calibre1">public int getValue() { return value; }</p>
<p class="calibre1">}</p>
<p class="calibre1">Java 5 has a series of new classes for situations like this: AtomicBoolean, AtomicInteger, and AtomicReference are three examples; there are several more. We can rewrite the above code to use a nonblocking approach as follows: public class ObjectWithValue {</p>
<p class="calibre1">private AtomicInteger value = new AtomicInteger(0);</p>
<p class="calibre1">public void incrementValue() {</p>
<p class="calibre1">value.incrementAndGet();</p>
<p class="calibre1">}</p>
<p class="calibre1">public int getValue() {</p>
<p class="calibre1">return value.get();</p>
<p class="calibre1">}</p>
<p class="calibre1">}</p>
<p class="calibre1">Even though this uses an object instead of a primitive and sends messages like incrementAndGet() instead of ++, the performance of this class will nearly always beat the previous version. In some cases it will only be slightly faster, but the cases where it will be slower are virtually nonexistent.</p>
<p class="calibre1">How is this possible? Modern processors have an operation typically called  <i class="calibre4">Compare</i> <i class="calibre4">and Swap (CAS)</i>. This operation is analogous to optimistic locking in databases, whereas the synchronized version is analogous to pessimistic locking.</p>
<p class="calibre1"><a id="p359"></a>328</p>
<p class="calibre1"><b class="calibre3">Appendix A: Concurrency II</b></p>
<p class="calibre1">The synchronized keyword always acquires a lock, even when a second thread is not trying to update the same value. Even though the performance of intrinsic locks has improved from version to version, they are still costly.</p>
<p class="calibre1">The nonblocking version starts with the assumption that multiple threads generally do not modify the same value often enough that a problem will arise. Instead, it efficiently detects whether such a situation has occurred and retries until the update happens successfully. This detection is almost always less costly than acquiring a lock, even in moderate to high contention situations.</p>
<p class="calibre1">How does the Virtual Machine accomplish this? The CAS operation is atomic. Logically, the CAS operation looks something like the following:</p>
<p class="calibre1">int variableBeingSet;</p>
<p class="calibre1">void simulateNonBlockingSet(int newValue) {</p>
<p class="calibre1">int currentValue;</p>
<p class="calibre1">do {</p>
<p class="calibre1">currentValue = variableBeingSet</p>
<p class="calibre1">} while(currentValue != compareAndSwap(currentValue, newValue));</p>
<p class="calibre1">}</p>
<p class="calibre1">int synchronized compareAndSwap(int currentValue, int newValue) {</p>
<p class="calibre1">if(variableBeingSet == currentValue) {</p>
<p class="calibre1">variableBeingSet = newValue;</p>
<p class="calibre1">return currentValue;</p>
<p class="calibre1">}</p>
<p class="calibre1">return variableBeingSet;</p>
<p class="calibre1">}</p>
<p class="calibre1">When a method attempts to update a shared variable, the CAS operation verifies that the variable getting set still has the last known value. If so, then the variable is changed. If not, then the variable is not set because another thread managed to get in the way. The method making the attempt (using the CAS operation) sees that the change was not made and retries.</p>
<p class="calibre1"><a href="index_split_000.html#p17"><b class="calibre3">Nonthread-Safe Classes</b></a></p>
<p class="calibre1">There are some classes that are inherently not thread safe. Here are a few examples:</p>
<p class="calibre1"><b class="calibre3">• </b>SimpleDateFormat</p>
<p class="calibre1"><b class="calibre3">• </b>Database Connections</p>
<p class="calibre1"><b class="calibre3">• </b>Containers in java.util</p>
<p class="calibre1"><b class="calibre3">• </b>Servlets</p>
<p class="calibre1">Note that some collection classes have individual methods that are thread-safe. However, any operation that involves calling more than one method is not. For example, if you do not want to replace something in a HashTable because it is already there, you might write the following code: if(!hashTable.containsKey(someKey)) {</p>
<p class="calibre1">hashTable.put(someKey, new SomeValue());</p>
<p class="calibre1">}</p>
<p class="calibre1"><a id="p360"></a><b class="calibre3">Dependencies Between Methods Can Break Concurrent Code</b> 329</p>
<p class="calibre1">Each individual method is thread-safe. However, another thread might add a value in between the containsKey and put calls. There are several options to fix this problem.</p>
<p class="calibre1"><b class="calibre3">• </b>Lock the HashTable first, and make sure all other users of the HashTable do the same—</p>
<p class="calibre1">client-based locking:</p>
<p class="calibre1">synchronized(map) {</p>
<p class="calibre1">if(!map.conainsKey(key))</p>
<p class="calibre1">map.put(key,value);</p>
<p class="calibre1">}</p>
<p class="calibre1"><b class="calibre3">• </b>Wrap the HashTable in its own object and use a different API—server-based locking using an ADAPTER:</p>
<p class="calibre1">public class WrappedHashtable&lt;K, V&gt; {</p>
<p class="calibre1">private Map&lt;K, V&gt; map = new Hashtable&lt;K, V&gt;();</p>
<p class="calibre1">public synchronized void putIfAbsent(K key, V value) {</p>
<p class="calibre1">if (map.containsKey(key))</p>
<p class="calibre1">map.put(key, value);</p>
<p class="calibre1">}</p>
<p class="calibre1">}</p>
<p class="calibre1"><b class="calibre3">• </b>Use the thread-safe collections:</p>
<p class="calibre1">ConcurrentHashMap&lt;Integer, String&gt; map = new ConcurrentHashMap&lt;Integer, String&gt;();</p>
<p class="calibre1">map.putIfAbsent(key, value);</p>
<p class="calibre1">The collections in java.util.concurrent have operations like putIfAbsent() to accommodate such operations.</p>
<p class="calibre1"><a href="index_split_000.html#p17"><b class="calibre3">Dependencies Between Methods </b></a></p>
<p class="calibre1"><a href="index_split_000.html#p17"><b class="calibre3">Can Break Concurrent Code</b></a></p>
<p class="calibre1">Here is a trivial example of a way to introduce dependencies between methods: public class IntegerIterator implements Iterator&lt;Integer&gt; private Integer nextValue = 0;</p>
<p class="calibre1">public synchronized boolean hasNext() {</p>
<p class="calibre1">return nextValue &lt; 100000;</p>
<p class="calibre1">}</p>
<p class="calibre1">public synchronized Integer next() {</p>
<p class="calibre1">if (nextValue == 100000)</p>
<p class="calibre1">throw new IteratorPastEndException();</p>
<p class="calibre1">return nextValue++;</p>
<p class="calibre1">}</p>
<p class="calibre1">public synchronized Integer getNextValue() {</p>
<p class="calibre1">return nextValue;</p>
<p class="calibre1">}</p>
<p class="calibre1">}</p>
<p class="calibre1">Here is some code to use this IntegerIterator:</p>
<p class="calibre1">IntegerIterator iterator = new IntegerIterator();</p>
<p class="calibre1">while(iterator.hasNext()) {</p>
<p class="calibre1"><a id="p361"></a>330</p>
<p class="calibre1"><b class="calibre3">Appendix A: Concurrency II</b></p>
<p class="calibre1">int nextValue = iterator.next();</p>
<p class="calibre1">// do something with nextValue</p>
<p class="calibre1">}</p>
<p class="calibre1">If one thread executes this code, there will be no problem. But what happens if two threads attempt to share a single instance of IngeterIterator with the intent that each thread will process the values it gets, but that each element of the list is processed only once? Most of the time, nothing bad happens; the threads happily share the list, processing the elements they are given by the iterator and stopping when the iterator is complete. However, there is a small chance that, at the end of the iteration, the two threads will interfere with each other and cause one thread to go beyond the end of the iterator and throw an exception.</p>
<p class="calibre1">Here’s the problem: Thread 1 asks the question hasNext(), which returns true. Thread 1 gets preempted and then Thread 2 asks the same question, which is still true. Thread 2</p>
<p class="calibre1">then calls next(), which returns a value as expected but has a side effect of making hasNext() return false. Thread 1 starts up again, thinking hasNext() is still true, and then calls  next(). Even though the individual methods are synchronized, the client uses <i class="calibre4"><b class="calibre3"> two</b></i></p>
<p class="calibre1">methods.</p>
<p class="calibre1">This is a real problem and an example of the kinds of problems that crop up in concurrent code. In this particular situation this problem is especially subtle because the only time where this causes a fault is when it happens during the final iteration of the iterator.</p>
<p class="calibre1">If the threads happen to break just right, then one of the threads could go beyond the end of the iterator. This is the kind of bug that happens long after a system has been in production, and it is hard to track down.</p>
<p class="calibre1">You have three options:</p>
<p class="calibre1"><b class="calibre3">• </b>Tolerate the failure.</p>
<p class="calibre1"><b class="calibre3">• </b>Solve the problem by changing the client: client-based locking</p>
<p class="calibre1"><b class="calibre3">• </b>Solve the problem by changing the server, which additionally changes the client: server-based locking</p>
<p class="calibre1"><a href="index_split_000.html#p17"><b class="calibre3">Tolerate the Failure</b></a></p>
<p class="calibre1">Sometimes you can set things up such that the failure causes no harm. For example, the above client could catch the exception and clean up. Frankly, this is a bit sloppy. It’s rather like cleaning up memory leaks by rebooting at midnight.</p>
<p class="calibre1"><a href="index_split_000.html#p17"><b class="calibre3">Client-Based Locking</b></a></p>
<p class="calibre1">To make IntegerIterator work correctly with multiple threads, change this client (and every other client) as follows:</p>
<p class="calibre1">IntegerIterator iterator = new IntegerIterator();</p>
<p class="calibre1">while (true) {</p>
<p class="calibre1">int nextValue;</p>
<p class="calibre1"><a id="p362"></a><b class="calibre3">Dependencies Between Methods Can Break Concurrent Code</b> 331</p>
<p class="calibre1">synchronized (iterator) {</p>
<p class="calibre1">if (!iterator.hasNext())</p>
<p class="calibre1">break;</p>
<p class="calibre1">nextValue = iterator.next();</p>
<p class="calibre1">}</p>
<p class="calibre1">doSometingWith(nextValue);</p>
<p class="calibre1">}</p>
<p class="calibre1">Each client introduces a lock via the synchronized keyword. This duplication violates the DRY principle, but it might be necessary if the code uses non-thread-safe third-party tools.</p>
<p class="calibre1">This strategy is risky because all programmers who use the server must remember to lock it before using it and unlock it when done. Many (many!) years ago I worked on a system that employed client-based locking on a shared resource. The resource was used in hundreds of different places throughout the code. One poor programmer forgot to lock the resource in one of those places.</p>
<p class="calibre1">The system was a multi-terminal time-sharing system running accounting software for Local 705 of the trucker’s union. The computer was in a raised-floor, environment-controlled room 50 miles north of the Local 705 headquarters. At the headquarters they had dozens of data entry clerks typing union dues postings into the terminals. The terminals were connected to the computer using dedicated phone lines and 600bps half-duplex modems. (This was a very,  <i class="calibre4">very</i> long time ago.) About once per day, one of the terminals would “lock up.” There was no rhyme or reason to it. The lock up showed no preference for particular terminals or particular times. It was as though there were someone rolling dice choosing the time and terminal to lock up.</p>
<p class="calibre1">Sometimes more than one terminal would lock up. Sometimes days would go by without any lock-ups.</p>
<p class="calibre1">At first the only solution was a reboot. But reboots were tough to coordinate. We had to call the headquarters and get everyone to finish what they were doing on all the terminals. Then we could shut down and restart. If someone was doing something important that took an hour or two, the locked up terminal simply had to stay locked up.</p>
<p class="calibre1">After a few weeks of debugging we found that the cause was a ring-buffer counter that had gotten out of sync with its pointer. This buffer controlled output to the terminal. The pointer value indicated that the buffer was empty, but the counter said it was full. Because it was empty, there was nothing to display; but because it was also full, nothing could be added to the buffer to be displayed on the screen.</p>
<p class="calibre1">So we knew why the terminals were locking, but we didn’t know why the ring buffer was getting out of sync. So we added a hack to work around the problem. It was possible to read the front panel switches on the computer. (This was a very, very,  <i class="calibre4">very</i> long time ago.) We wrote a little trap function that detected when one of these switches was thrown and then looked for a ring buffer that was both empty and full. If one was found, it reset that buffer to empty.  <i class="calibre4">Voila! </i> The locked-up terminal(s) started displaying again.</p>
<p class="calibre1">So now we didn’t have to reboot the system when a terminal locked up. The Local would simply call us and tell us we had a lock-up, and then we just walked into the computer room and flicked a switch.</p>
<p class="calibre1"><a id="p363"></a>332</p>
<p class="calibre1"><b class="calibre3">Appendix A: Concurrency II</b></p>
<p class="calibre1">Of course sometimes they worked on the weekends, and we didn’t. So we added a function to the scheduler that checked all the ring buffers once per minute and reset any that were both empty and full. This caused the displays to unclog before the Local could even get on the phone.</p>
<p class="calibre1">It was several more weeks of poring over page after page of monolithic assembly language code before we found the culprit. We had done the math and calculated that the frequency of the lock-ups was consistent with a single unprotected use of the ring buffer. So all we had to do was find that one faulty usage. Unfortunately, this was so very long ago that we didn’t have search tools or cross references or any other kind of automated help.</p>
<p class="calibre1">We simply had to pore over listings.</p>
<p class="calibre1">I learned an important lesson that cold Chicago winter of 1971. Client-based locking really blows.</p>
<p class="calibre1"><a href="index_split_000.html#p17"><b class="calibre3">Server-Based Locking</b></a></p>
<p class="calibre1">The duplication can be removed by making the following changes to IntegerIterator: public class IntegerIteratorServerLocked {</p>
<p class="calibre1">private Integer nextValue = 0;</p>
<p class="calibre1">public synchronized Integer getNextOrNull() {</p>
<p class="calibre1">if (nextValue &lt; 100000)</p>
<p class="calibre1">return nextValue++;</p>
<p class="calibre1">else</p>
<p class="calibre1">return null;</p>
<p class="calibre1">}</p>
<p class="calibre1">}</p>
<p class="calibre1">And the client code changes as well:</p>
<p class="calibre1">while (true) {</p>
<p class="calibre1">Integer nextValue = iterator.getNextOrNull();</p>
<p class="calibre1">if (next == null)</p>
<p class="calibre1">break;</p>
<p class="calibre1">// do something with nextValue</p>
<p class="calibre1">}</p>
<p class="calibre1">In this case we actually change the API of our class to be multithread aware.3 The client needs to perform a null check instead of checking hasNext().</p>
<p class="calibre1">In general you should prefer server-based locking for these reasons:</p>
<p class="calibre1"><b class="calibre3">• </b>It reduces repeated code—Client-based locking forces each client to lock the server properly. By putting the locking code into the server, clients are free to use the object and not worry about writing additional locking code.</p>
<p class="calibre1">3.</p>
<p class="calibre1">In fact, the Iterator interface is inherently not thread-safe. It was never designed to be used by multiple threads, so this should come as no surprise.</p>
<p class="calibre1"><a id="p364"></a><b class="calibre3">Increasing Throughput</b></p>
<p class="calibre1">333</p>
<p class="calibre1"><b class="calibre3">• </b>It allows for better performance—You can swap out a thread-safe server for a nonthread safe one in the case of single-threaded deployment, thereby avoiding all overhead.</p>
<p class="calibre1"><b class="calibre3">• </b>It reduces the possibility of error—All it takes is for one programmer to forget to lock properly.</p>
<p class="calibre1"><b class="calibre3">• </b>It enforces a single policy—The policy is in one place, the server, rather than many places, each client.</p>
<p class="calibre1"><b class="calibre3">• </b>It reduces the scope of the shared variables—The client is not aware of them or how they are locked. All of that is hidden in the server. When things break, the number of places to look is smaller.</p>
<p class="calibre1">What if you do not own the server code?</p>
<p class="calibre1"><b class="calibre3">• </b>Use an ADAPTER to change the API and add locking</p>
<p class="calibre1">public class ThreadSafeIntegerIterator {</p>
<p class="calibre1">private IntegerIterator iterator = new IntegerIterator();</p>
<p class="calibre1">public synchronized Integer getNextOrNull() {</p>
<p class="calibre1">if(iterator.hasNext())</p>
<p class="calibre1">return iterator.next();</p>
<p class="calibre1">return null;</p>
<p class="calibre1">}</p>
<p class="calibre1">}</p>
<p class="calibre1"><b class="calibre3">• </b>OR better yet, use the thread-safe collections with extended interfaces</p>
<p class="calibre1"><a href="index_split_000.html#p17"><b class="calibre3">Increasing Throughput</b></a></p>
<p class="calibre1">Let’s assume that we want to go out on the net and read the contents of a set of pages from a list of URLs. As each page is read, we will parse it to accumulate some statistics. Once all the pages are read, we will print a summary report.</p>
<p class="calibre1">The following class returns the contents of one page, given a URL.</p>
<p class="calibre1">public class PageReader {</p>
<p class="calibre1">//...</p>
<p class="calibre1">public String getPageFor(String url) {</p>
<p class="calibre1">HttpMethod method = new GetMethod(url);</p>
<p class="calibre1">try {</p>
<p class="calibre1">httpClient.executeMethod(method);</p>
<p class="calibre1">String response = method.getResponseBodyAsString();</p>
<p class="calibre1">return response;</p>
<p class="calibre1">} catch (Exception e) {</p>
<p class="calibre1">handle(e);</p>
<p class="calibre1">} finally {</p>
<p class="calibre1">method.releaseConnection();</p>
<p class="calibre1">}</p>
<p class="calibre1">}</p>
<p class="calibre1">}</p>
<p class="calibre1"><a id="p365"></a><img src="index-365_1.png" alt="Image 48" class="calibre2"/></p>
<p class="calibre1">334</p>
<p class="calibre1"><b class="calibre3">Appendix A: Concurrency II</b></p>
<p class="calibre1">The next class is the iterator that provides the contents of the pages based on an iterator of URLs:</p>
<p class="calibre1">public class PageIterator {</p>
<p class="calibre1">private PageReader reader;</p>
<p class="calibre1">private URLIterator urls;</p>
<p class="calibre1">public PageIterator(PageReader reader, URLIterator urls) {</p>
<p class="calibre1">this.urls = urls;</p>
<p class="calibre1">this.reader = reader;</p>
<p class="calibre1">}</p>
<p class="calibre1">public synchronized String getNextPageOrNull() {</p>
<p class="calibre1">if (urls.hasNext())</p>
<p class="calibre1">getPageFor(urls.next());</p>
<p class="calibre1">else</p>
<p class="calibre1">return null;</p>
<p class="calibre1">}</p>
<p class="calibre1">public String getPageFor(String url) {</p>
<p class="calibre1">return reader.getPageFor(url);</p>
<p class="calibre1">}</p>
<p class="calibre1">}</p>
<p class="calibre1">An instance of the PageIterator can be shared between many different threads, each one using it’s own instance of the PageReader to read and parse the pages it gets from the iterator.</p>
<p class="calibre1">Notice that we’ve kept the synchronized block very small. It contains just the critical section deep inside the PageIterator. It is always better to synchronize as little as possible as opposed to synchronizing as much as possible.</p>
<p class="calibre1"><a href="index_split_000.html#p17"><b class="calibre3">Single-Thread Calculation of Throughput</b></a></p>
<p class="calibre1">Now lets do some simple calculations. For the purpose of argument, assume the following:</p>
<p class="calibre1"><b class="calibre3">• </b>I/O time to retrieve a page (average): 1 second</p>
<p class="calibre1"><b class="calibre3">• </b>Processing time to parse page (average): .5 seconds</p>
<p class="calibre1"><b class="calibre3">• </b>I/O requires 0 percent of the CPU while processing requires 100 percent.</p>
<p class="calibre1">For  <i class="calibre4">N</i>  pages being processed by a single thread, the total execution time is 1.5 seconds *  <i class="calibre4">N</i>. Figure A-1 shows a snapshot of 13 pages or about 19.5 seconds.</p>
<p class="calibre1"><b class="calibre3">Figure A-1</b></p>
<p class="calibre1">Single thread</p>
<p class="calibre1"><a id="p366"></a><img src="index-366_1.png" alt="Image 49" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">Deadlock</b></p>
<p class="calibre1">335</p>
<p class="calibre1"><a href="index_split_000.html#p17"><b class="calibre3">Multithread Calculation of Throughput</b></a></p>
<p class="calibre1">If it is possible to retrieve pages in any order and process the pages independently, then it is possible to use multiple threads to increase throughput. What happens if we use three threads? How many pages can we acquire in the same time?</p>
<p class="calibre1">As you can see in Figure A-2, the multithreaded solution allows the process-bound parsing of the pages to overlap with the I/O-bound reading of the pages. In an idealized world this means that the processor is fully utilized. Each one-second page read is over-lapped with two parses. Thus, we can process two pages per second, which is three times the throughput of the single-threaded solution.</p>
<p class="calibre1"><b class="calibre3">Figure A-2</b></p>
<p class="calibre1">Three concurrent threads</p>
<p class="calibre1"><a href="index_split_000.html#p17"><b class="calibre3">Deadlock</b></a></p>
<p class="calibre1">Imagine a Web application with two shared resource pools of some finite size:</p>
<p class="calibre1"><b class="calibre3">• </b>A pool of database connections for local work in process storage</p>
<p class="calibre1"><b class="calibre3">• </b>A pool of MQ connections to a master repository</p>
<p class="calibre1">Assume there are two operations in this application, create and update:</p>
<p class="calibre1"><b class="calibre3">• </b>Create—Acquire connection to master repository and database. Talk to service master repository and then store work in local work in process database.</p>
<p class="calibre1"><a id="p367"></a>336</p>
<p class="calibre1"><b class="calibre3">Appendix A: Concurrency II</b></p>
<p class="calibre1"><b class="calibre3">• </b>Update—Acquire connection to database and then master repository. Read from work in process database and then send to the master repository</p>
<p class="calibre1">What happens when there are more users than the pool sizes? Consider each pool has a size of ten.</p>
<p class="calibre1"><b class="calibre3">• </b>Ten users attempt to use create, so all ten database connections are acquired, and each thread is interrupted after acquiring a database connection but before acquiring a connection to the master repository.</p>
<p class="calibre1"><b class="calibre3">• </b>Ten users attempt to use update, so all ten master repository connections are acquired, and each thread is interrupted after acquiring the master repository but before acquiring a database connection.</p>
<p class="calibre1"><b class="calibre3">• </b>Now the ten “create” threads must wait to acquire a master repository connection, but the ten “update” threads must wait to acquire a database connection.</p>
<p class="calibre1"><b class="calibre3">• </b>Deadlock. The system never recovers.</p>
<p class="calibre1">This might sound like an unlikely situation, but who wants a system that freezes solid every other week? Who wants to debug a system with symptoms that are so difficult to reproduce? This is the kind of problem that happens in the field, then takes weeks to solve.</p>
<p class="calibre1">A typical “solution” is to introduce debugging statements to find out what is happening. Of course, the debug statements change the code enough so that the deadlock happens in a different situation and takes months to again occur.4</p>
<p class="calibre1">To really solve the problem of deadlock, we need to understand what causes it. There are four conditions required for deadlock to occur:</p>
<p class="calibre1"><b class="calibre3">• </b>Mutual exclusion</p>
<p class="calibre1"><b class="calibre3">• </b>Lock &amp; wait</p>
<p class="calibre1"><b class="calibre3">• </b>No preemption</p>
<p class="calibre1"><b class="calibre3">• </b>Circular wait</p>
<p class="calibre1"><a href="index_split_000.html#p17"><b class="calibre3">Mutual Exclusion</b></a></p>
<p class="calibre1">Mutual exclusion occurs when multiple threads need to use the same resources and those resources</p>
<p class="calibre1"><b class="calibre3">• </b>Cannot be used by multiple threads at the same time.</p>
<p class="calibre1"><b class="calibre3">• </b>Are limited in number.</p>
<p class="calibre1">A common example of such a resource is a database connection, a file open for write, a record lock, or a semaphore.</p>
<p class="calibre1">4.</p>
<p class="calibre1">For example, someone adds some debugging output and the problem “disappears.” The debugging code “fixes” the problem so it remains in the system.</p>
<p class="calibre1"><a id="p368"></a><img src="index-368_1.png" alt="Image 50" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">Deadlock</b></p>
<p class="calibre1">337</p>
<p class="calibre1"><a href="index_split_000.html#p17"><b class="calibre3">Lock &amp; Wait</b></a></p>
<p class="calibre1">Once a thread acquires a resource, it will not release the resource until it has acquired all of the other resources it requires and has completed its work.</p>
<p class="calibre1"><a href="index_split_000.html#p18"><b class="calibre3">No Preemption</b></a></p>
<p class="calibre1">One thread cannot take resources away from another thread. Once a thread holds a resource, the only way for another thread to get it is for the holding thread to release it.</p>
<p class="calibre1"><a href="index_split_000.html#p18"><b class="calibre3">Circular Wait</b></a></p>
<p class="calibre1">This is also referred to as the deadly embrace. Imagine two threads, T1 and T2, and two resources, R1 and R2. T1 has R1, T2 has R2. T1 also requires R2, and T2 also requires R1.</p>
<p class="calibre1">This gives something like Figure A-3:</p>
<p class="calibre1"><b class="calibre3">Figure A-3</b></p>
<p class="calibre1">All four of these conditions must hold for deadlock to be possible. Break any one of these conditions and deadlock is not possible.</p>
<p class="calibre1"><a href="index_split_000.html#p18"><b class="calibre3">Breaking Mutual Exclusion</b></a></p>
<p class="calibre1">One strategy for avoiding deadlock is to sidestep the mutual exclusion condition. You might be able to do this by</p>
<p class="calibre1"><b class="calibre3">• </b>Using resources that allow simultaneous use, for example, AtomicInteger.</p>
<p class="calibre1"><b class="calibre3">• </b>Increasing the number of resources such that it equals or exceeds the number of competing threads.</p>
<p class="calibre1"><b class="calibre3">• </b>Checking that all your resources are free before seizing any.</p>
<p class="calibre1">Unfortunately, most resources are limited in number and don’t allow simultaneous use. And it’s not uncommon for the identity of the second resource to be predicated on the results of operating on the first. But don’t be discouraged; there are three conditions left.</p>
<p class="calibre1"><a id="p369"></a>338</p>
<p class="calibre1"><b class="calibre3">Appendix A: Concurrency II</b></p>
<p class="calibre1"><a href="index_split_000.html#p18"><b class="calibre3">Breaking Lock &amp; Wait</b></a></p>
<p class="calibre1">You can also eliminate deadlock if you refuse to wait. Check each resource before you seize it, and release all resources and start over if you run into one that’s busy.</p>
<p class="calibre1">This approach introduces several potential problems:</p>
<p class="calibre1"><b class="calibre3">• </b>Starvation—One thread keeps being unable to acquire the resources it needs (maybe it has a unique combination of resources that seldom all become available).</p>
<p class="calibre1"><b class="calibre3">• </b>Livelock—Several threads might get into lockstep and all acquire one resource and then release one resource, over and over again. This is especially likely with simplistic CPU scheduling algorithms (think embedded devices or simplistic hand-written thread balancing algorithms).</p>
<p class="calibre1">Both of these can cause poor throughput. The first results in low CPU utilization, whereas the second results in high and useless CPU utilization.</p>
<p class="calibre1">As inefficient as this strategy sounds, it’s better than nothing. It has the benefit that it can almost always be implemented if all else fails.</p>
<p class="calibre1"><a href="index_split_000.html#p18"><b class="calibre3">Breaking Preemption</b></a></p>
<p class="calibre1">Another strategy for avoiding deadlock is to allow threads to take resources away from other threads. This is usually done through a simple request mechanism. When a thread discovers that a resource is busy, it asks the owner to release it. If the owner is also waiting for some other resource, it releases them all and starts over.</p>
<p class="calibre1">This is similar to the previous approach but has the benefit that a thread is allowed to wait for a resource. This decreases the number of startovers. Be warned, however, that managing all those requests can be tricky.</p>
<p class="calibre1"><a href="index_split_000.html#p18"><b class="calibre3">Breaking Circular Wait</b></a></p>
<p class="calibre1">This is the most common approach to preventing deadlock. For most systems it requires no more than a simple convention agreed to by all parties.</p>
<p class="calibre1">In the example above with Thread 1 wanting both Resource 1 and Resource 2 and Thread 2 wanting both Resource 2 and then Resource 1, simply forcing both Thread 1 and Thread 2 to allocate resources in the same order makes circular wait impossible.</p>
<p class="calibre1">More generally, if all threads can agree on a global ordering of resources and if they all allocate resources in that order, then deadlock is impossible. Like all the other strategies, this can cause problems: <b class="calibre3">• </b>The order of acquisition might not correspond to the order of use; thus a resource acquired at the start might not be used until the end. This can cause resources to be locked longer than strictly necessary.</p>
<p class="calibre1"><a id="p370"></a><b class="calibre3">Testing Multithreaded Code</b></p>
<p class="calibre1">339</p>
<p class="calibre1"><b class="calibre3">• </b>Sometimes you cannot impose an order on the acquisition of resources. If the ID of the second resource comes from an operation performed on the first, then ordering is not feasible.</p>
<p class="calibre1">So there are many ways to avoid deadlock. Some lead to starvation, whereas others make heavy use of the CPU and reduce responsiveness. TANSTAAFL!5</p>
<p class="calibre1">Isolating the thread-related part of your solution to allow for tuning and experimenta-tion is a powerful way to gain the insights needed to determine the best strategies.</p>
<p class="calibre1"><a href="index_split_000.html#p18"><b class="calibre3">Testing Multithreaded Code</b></a></p>
<p class="calibre1">How can we write a test to demonstrate the following code is broken?</p>
<p class="calibre1">01: public class ClassWithThreadingProblem {</p>
<p class="calibre1">02:    int nextId;</p>
<p class="calibre1">03:</p>
<p class="calibre1">04:    public int takeNextId() {</p>
<p class="calibre1">05:        return nextId++;</p>
<p class="calibre1">06:    }</p>
<p class="calibre1">07:}</p>
<p class="calibre1">Here’s a description of a test that will prove the code is broken:</p>
<p class="calibre1"><b class="calibre3">• </b>Remember the current value of nextId.</p>
<p class="calibre1"><b class="calibre3">• </b>Create two threads, both of which call takeNextId() once.</p>
<p class="calibre1"><b class="calibre3">• </b>Verify that nextId is two more than what we started with.</p>
<p class="calibre1"><b class="calibre3">• </b>Run this until we demonstrate that nextId was only incremented by one instead of two.</p>
<p class="calibre1">Listing A-2 shows such a test:</p>
<p class="calibre1"><b class="calibre3">Listing A-2 </b></p>
<p class="calibre1"><b class="calibre3">ClassWithThreadingProblemTest.java</b></p>
<p class="calibre1">01: package example;</p>
<p class="calibre1">02:</p>
<p class="calibre1">03: import static org.junit.Assert.fail;</p>
<p class="calibre1">04:</p>
<p class="calibre1">05: import org.junit.Test;</p>
<p class="calibre1">06:</p>
<p class="calibre1">07: public class ClassWithThreadingProblemTest {</p>
<p class="calibre1">08:     @Test</p>
<p class="calibre1">09:     public void twoThreadsShouldFailEventually() throws Exception {</p>
<p class="calibre1">10:         final ClassWithThreadingProblem classWithThreadingProblem</p>
<p class="calibre1">= new ClassWithThreadingProblem();</p>
<p class="calibre1">11:</p>
<p class="calibre1">5.</p>
<p class="calibre1">There ain’t no such thing as a free lunch.</p>
<p class="calibre1"><a id="p371"></a>340</p>
<p class="calibre1"><b class="calibre3">Appendix A: Concurrency II</b></p>
<p class="calibre1"><b class="calibre3">Listing A-2 (continued)</b></p>
<p class="calibre1"><b class="calibre3">ClassWithThreadingProblemTest.java</b></p>
<p class="calibre1">12:         Runnable runnable = new Runnable() {</p>
<p class="calibre1">13:             public void run() {</p>
<p class="calibre1">14:                 classWithThreadingProblem.takeNextId();</p>
<p class="calibre1">15:             }</p>
<p class="calibre1">16:         };</p>
<p class="calibre1">17:</p>
<p class="calibre1">18:         for (int i = 0; i &lt; 50000; ++i) {</p>
<p class="calibre1">19:             int startingId = classWithThreadingProblem.lastId; 20:             int expectedResult = 2 + startingId;</p>
<p class="calibre1">21:</p>
<p class="calibre1">22:             Thread t1 = new Thread(runnable);</p>
<p class="calibre1">23:             Thread t2 = new Thread(runnable);</p>
<p class="calibre1">24:             t1.start();</p>
<p class="calibre1">25:             t2.start();</p>
<p class="calibre1">26:             t1.join();</p>
<p class="calibre1">27:             t2.join();</p>
<p class="calibre1">28:</p>
<p class="calibre1">29:             int endingId = classWithThreadingProblem.lastId; 30:</p>
<p class="calibre1">31:             if (endingId != expectedResult)</p>
<p class="calibre1">32:                 return;</p>
<p class="calibre1">33:         }</p>
<p class="calibre1">34:</p>
<p class="calibre1">35:         fail("Should have exposed a threading issue but it did not."); 36:     }</p>
<p class="calibre1">37: }</p>
<p class="calibre1"><b class="calibre3">Line</b></p>
<p class="calibre1"><b class="calibre3">Description</b></p>
<p class="calibre1">10</p>
<p class="calibre1">Create a single instance of ClassWithThreadingProblem. Note, we must use the final keyword because we use it below in an anonymous inner class.</p>
<p class="calibre1">12–16</p>
<p class="calibre1">Create an anonymous inner class that uses the single instance of ClassWithThreadingProblem.</p>
<p class="calibre1">18</p>
<p class="calibre1">Run this code “enough” times to demonstrate that the code failed, but not so much that the test “takes too long.” This is a balancing act; we don’t want to wait too long to demonstrate failure. Picking this number is hard— although later we’ll see that we can greatly reduce this number.</p>
<p class="calibre1">19</p>
<p class="calibre1">Remember the starting value. This test is trying to prove that the code in ClassWithThreadingProblem is broken. If this test passes, it proved that the code was broken. If this test fails, the test was unable to prove that the code is broken.</p>
<p class="calibre1">20</p>
<p class="calibre1">We expect the final value to be two more than the current value.</p>
<p class="calibre1">22–23</p>
<p class="calibre1">Create two threads, both of which use the object we created in lines 12–16.</p>
<p class="calibre1">This gives us the potential of two threads trying to use our single instance of ClassWithThreadingProblem and interfering with each other.</p>
<p class="calibre1"><a id="p372"></a><b class="calibre3">Testing Multithreaded Code</b></p>
<p class="calibre1">341</p>
<p class="calibre1"><b class="calibre3">Line</b></p>
<p class="calibre1"><b class="calibre3">Description</b></p>
<p class="calibre1">24–25</p>
<p class="calibre1">Make our two threads eligible to run.</p>
<p class="calibre1">26–27</p>
<p class="calibre1">Wait for both threads to finish before we check the results.</p>
<p class="calibre1">29</p>
<p class="calibre1">Record the actual final value.</p>
<p class="calibre1">31–32</p>
<p class="calibre1">Did our endingId differ from what we expected? If so, return end the test—</p>
<p class="calibre1">we’ve proven that the code is broken. If not, try again.</p>
<p class="calibre1">35</p>
<p class="calibre1">If we got to here, our test was unable to prove the production code was broken in a “reasonable” amount of time; our code has failed. Either the code is not broken or we didn’t run enough iterations to get the failure condition to occur.</p>
<p class="calibre1">This test certainly sets up the conditions for a concurrent update problem. However, the problem occurs so infrequently that the vast majority of times this test won’t detect it.</p>
<p class="calibre1">Indeed, to truly detect the problem we need to set the number of iterations to over one million. Even then, in ten executions with a loop count of 1,000,000, the problem occurred only once. That means we probably ought to set the iteration count to well over one hundred million to get reliable failures. How long are we prepared to wait?</p>
<p class="calibre1">Even if we tuned the test to get reliable failures on one machine, we’ll probably have to retune the test with different values to demonstrate the failure on another machine, operating system, or version of the JVM.</p>
<p class="calibre1">And this is a  <i class="calibre4">simple</i> problem. If we cannot demonstrate broken code easily with this problem, how will we ever detect truly complex problems?</p>
<p class="calibre1">So what approaches can we take to demonstrate this simple failure? And, more importantly, how can we write tests that will demonstrate failures in more complex code? How will we be able to discover if our code has failures when we do not know where to look?</p>
<p class="calibre1">Here are a few ideas:</p>
<p class="calibre1"><b class="calibre3">• Monte Carlo Testing. </b> Make tests flexible, so they can be tuned. Then run the test over and over—say on a test server—randomly changing the tuning values. If the tests ever fail, the code is broken. Make sure to start writing those tests early so a continuous integration server starts running them soon. By the way, make sure you carefully log the conditions under which the test failed.</p>
<p class="calibre1"><b class="calibre3">• </b>Run the test on every one of the target deployment platforms. Repeatedly. Continuously. The longer the tests run without failure, the more likely that</p>
<p class="calibre1">– The production code is correct or</p>
<p class="calibre1">– The tests aren’t adequate to expose problems.</p>
<p class="calibre1"><b class="calibre3">• </b>Run the tests on a machine with varying loads. If you can simulate loads close to a production environment, do so.</p>
<p class="calibre1"><a id="p373"></a>342</p>
<p class="calibre1"><b class="calibre3">Appendix A: Concurrency II</b></p>
<p class="calibre1">Yet, even if you do all of these things, you still don’t stand a very good chance of finding threading problems with your code. The most insidious problems are the ones that have such a small cross section that they only occur once in a billion opportunities. Such problems are the terror of complex systems.</p>
<p class="calibre1"><a href="index_split_000.html#p18"><b class="calibre3">Tool Support for Testing Thread-Based Code</b></a></p>
<p class="calibre1">IBM has created a tool called ConTest.6 It instruments classes to make it more likely that non-thread-safe code fails.</p>
<p class="calibre1">We do not have any direct relationship with IBM or the team that developed ConTest.</p>
<p class="calibre1">A colleague of ours pointed us to it. We noticed vast improvement in our ability to find threading issues after a few minutes of using it.</p>
<p class="calibre1">Here’s an outline of how to use ConTest:</p>
<p class="calibre1"><b class="calibre3">• </b>Write tests and production code, making sure there are tests specifically designed to simulate multiple users under varying loads, as mentioned above.</p>
<p class="calibre1"><b class="calibre3">• </b>Instrument test and production code with ConTest.</p>
<p class="calibre1"><b class="calibre3">• </b>Run the tests.</p>
<p class="calibre1">When we instrumented code with ConTest, our success rate went from roughly one failure in ten million iterations to roughly one failure in  <i class="calibre4">thirty</i> iterations. Here are the loop values for several runs of the test after instrumentation: 13, 23, 0, 54, 16, 14, 6, 69, 107, 49, 2. So clearly the instrumented classes failed much earlier and with much greater reliability.</p>
<p class="calibre1"><a href="index_split_000.html#p18"><b class="calibre3">Conclusion</b></a></p>
<p class="calibre1">This chapter has been a very brief sojourn through the large and treacherous territory of concurrent programming. We barely scratched the surface. Our emphasis here was on disciplines to help keep concurrent code clean, but there is much more you should learn if you are going to be writing concurrent systems. We recommend you start with Doug Lea’s wonderful book  <i class="calibre4">Concurrent Programming in Java: Design Principles and Patterns. </i> 7</p>
<p class="calibre1">In this chapter we talked about concurrent update, and the disciplines of clean synchronization and locking that can prevent it. We talked about how threads can enhance the throughput of an I/O-bound system and showed the clean techniques for achieving such improvements. We talked about deadlock and the disciplines for preventing it in a clean 6.</p>
<p class="calibre1"><a href="http://www.haifa.ibm.com/projects/verification/contest/index.html">http://www.haifa.ibm.com/projects/verification/contest/index.html</a></p>
<p class="calibre1">7.</p>
<p class="calibre1">See [Lea99] p. 191.</p>
<p class="calibre1"><a id="p374"></a><b class="calibre3">Tutorial: Full Code Examples</b></p>
<p class="calibre1">343</p>
<p class="calibre1">way. Finally, we talked about strategies for exposing concurrent problems by instrumenting your code.</p>
<p class="calibre1"><a href="index_split_000.html#p18"><b class="calibre3">Tutorial: Full Code Examples</b></a></p>
<p class="calibre1"><a href="index_split_000.html#p18"><b class="calibre3">Client/Server Nonthreaded    </b></a></p>
<p class="calibre1"><b class="calibre3">Listing A-3 </b></p>
<p class="calibre1"><b class="calibre3">Server.java</b></p>
<p class="calibre1">package com.objectmentor.clientserver.nonthreaded;</p>
<p class="calibre1">import java.io.IOException;</p>
<p class="calibre1">import java.net.ServerSocket;</p>
<p class="calibre1">import java.net.Socket;</p>
<p class="calibre1">import java.net.SocketException;</p>
<p class="calibre1">import common.MessageUtils;</p>
<p class="calibre1">public class Server implements Runnable {</p>
<p class="calibre1">ServerSocket serverSocket;</p>
<p class="calibre1">volatile boolean keepProcessing = true;</p>
<p class="calibre1">public Server(int port, int millisecondsTimeout) throws IOException {</p>
<p class="calibre1">serverSocket = new ServerSocket(port);</p>
<p class="calibre1">serverSocket.setSoTimeout(millisecondsTimeout);</p>
<p class="calibre1">}</p>
<p class="calibre1">public void run() {</p>
<p class="calibre1">System.out.printf("Server Starting\n");</p>
<p class="calibre1">while (keepProcessing) {</p>
<p class="calibre1">try {</p>
<p class="calibre1">System.out.printf("accepting client\n");</p>
<p class="calibre1">Socket socket = serverSocket.accept();</p>
<p class="calibre1">System.out.printf("got client\n");</p>
<p class="calibre1">process(socket);</p>
<p class="calibre1">} catch (Exception e) {</p>
<p class="calibre1">handle(e);</p>
<p class="calibre1">}</p>
<p class="calibre1">}</p>
<p class="calibre1">}</p>
<p class="calibre1">private void handle(Exception e) {</p>
<p class="calibre1">if (!(e instanceof SocketException)) {</p>
<p class="calibre1">e.printStackTrace();</p>
<p class="calibre1">}</p>
<p class="calibre1">}</p>
<p class="calibre1">public void stopProcessing() {</p>
<p class="calibre1">keepProcessing = false;</p>
<p class="calibre1">closeIgnoringException(serverSocket);</p>
<p class="calibre1">}</p>
<p class="calibre1"><a id="p375"></a>344</p>
<p class="calibre1"><b class="calibre3">Appendix A: Concurrency II</b></p>
<p class="calibre1"><b class="calibre3">Listing A-3 (continued)</b></p>
<p class="calibre1"><b class="calibre3">Server.java</b></p>
<p class="calibre1">void process(Socket socket) {</p>
<p class="calibre1">if (socket == null)</p>
<p class="calibre1">return;</p>
<p class="calibre1">try {</p>
<p class="calibre1">System.out.printf("Server: getting message\n");</p>
<p class="calibre1">String message = MessageUtils.getMessage(socket);</p>
<p class="calibre1">System.out.printf("Server: got message: %s\n", message); Thread.sleep(1000);</p>
<p class="calibre1">System.out.printf("Server: sending reply: %s\n", message); MessageUtils.sendMessage(socket, "Processed: " + message); System.out.printf("Server: sent\n");</p>
<p class="calibre1">closeIgnoringException(socket);</p>
<p class="calibre1">} catch (Exception e) {</p>
<p class="calibre1">e.printStackTrace();</p>
<p class="calibre1">}</p>
<p class="calibre1">}</p>
<p class="calibre1">private void closeIgnoringException(Socket socket) {</p>
<p class="calibre1">if (socket != null)</p>
<p class="calibre1">try {</p>
<p class="calibre1">socket.close();</p>
<p class="calibre1">} catch (IOException ignore) {</p>
<p class="calibre1">}</p>
<p class="calibre1">}</p>
<p class="calibre1">private void closeIgnoringException(ServerSocket serverSocket) {</p>
<p class="calibre1">if (serverSocket != null)</p>
<p class="calibre1">try {</p>
<p class="calibre1">serverSocket.close();</p>
<p class="calibre1">} catch (IOException ignore) {</p>
<p class="calibre1">}</p>
<p class="calibre1">}</p>
<p class="calibre1">}</p>
<p class="calibre1"><b class="calibre3">Listing A-4 </b></p>
<p class="calibre1"><b class="calibre3">ClientTest.java</b></p>
<p class="calibre1">package com.objectmentor.clientserver.nonthreaded;</p>
<p class="calibre1">import java.io.IOException;</p>
<p class="calibre1">import java.net.ServerSocket;</p>
<p class="calibre1">import java.net.Socket;</p>
<p class="calibre1">import java.net.SocketException;</p>
<p class="calibre1">import common.MessageUtils;</p>
<p class="calibre1">public class Server implements Runnable {</p>
<p class="calibre1">ServerSocket serverSocket;</p>
<p class="calibre1">volatile boolean keepProcessing = true;</p>
<p class="calibre1"><a id="p376"></a><b class="calibre3">Tutorial: Full Code Examples</b></p>
<p class="calibre1">345</p>
<p class="calibre1"><b class="calibre3">Listing A-4 (continued)</b></p>
<p class="calibre1"><b class="calibre3">ClientTest.java</b></p>
<p class="calibre1">public Server(int port, int millisecondsTimeout) throws IOException {</p>
<p class="calibre1">serverSocket = new ServerSocket(port);</p>
<p class="calibre1">serverSocket.setSoTimeout(millisecondsTimeout);</p>
<p class="calibre1">}</p>
<p class="calibre1">public void run() {</p>
<p class="calibre1">System.out.printf("Server Starting\n");</p>
<p class="calibre1">while (keepProcessing) {</p>
<p class="calibre1">try {</p>
<p class="calibre1">System.out.printf("accepting client\n");</p>
<p class="calibre1">Socket socket = serverSocket.accept();</p>
<p class="calibre1">System.out.printf("got client\n");</p>
<p class="calibre1">process(socket);</p>
<p class="calibre1">} catch (Exception e) {</p>
<p class="calibre1">handle(e);</p>
<p class="calibre1">}</p>
<p class="calibre1">}</p>
<p class="calibre1">}</p>
<p class="calibre1">private void handle(Exception e) {</p>
<p class="calibre1">if (!(e instanceof SocketException)) {</p>
<p class="calibre1">e.printStackTrace();</p>
<p class="calibre1">}</p>
<p class="calibre1">}</p>
<p class="calibre1">public void stopProcessing() {</p>
<p class="calibre1">keepProcessing = false;</p>
<p class="calibre1">closeIgnoringException(serverSocket);</p>
<p class="calibre1">}</p>
<p class="calibre1">void process(Socket socket) {</p>
<p class="calibre1">if (socket == null)</p>
<p class="calibre1">return;</p>
<p class="calibre1">try {</p>
<p class="calibre1">System.out.printf("Server: getting message\n");</p>
<p class="calibre1">String message = MessageUtils.getMessage(socket);</p>
<p class="calibre1">System.out.printf("Server: got message: %s\n", message); Thread.sleep(1000);</p>
<p class="calibre1">System.out.printf("Server: sending reply: %s\n", message); MessageUtils.sendMessage(socket, "Processed: " + message); System.out.printf("Server: sent\n");</p>
<p class="calibre1">closeIgnoringException(socket);</p>
<p class="calibre1">} catch (Exception e) {</p>
<p class="calibre1">e.printStackTrace();</p>
<p class="calibre1">}</p>
<p class="calibre1">}</p>
<p class="calibre1">private void closeIgnoringException(Socket socket) {</p>
<p class="calibre1">if (socket != null)</p>
<p class="calibre1">try {</p>
<p class="calibre1">socket.close();</p>
<p class="calibre1"><a id="p377"></a>346</p>
<p class="calibre1"><b class="calibre3">Appendix A: Concurrency II</b></p>
<p class="calibre1"><b class="calibre3">Listing A-4 (continued)</b></p>
<p class="calibre1"><b class="calibre3">ClientTest.java</b></p>
<p class="calibre1">} catch (IOException ignore) {</p>
<p class="calibre1">}</p>
<p class="calibre1">}</p>
<p class="calibre1">private void closeIgnoringException(ServerSocket serverSocket) {</p>
<p class="calibre1">if (serverSocket != null)</p>
<p class="calibre1">try {</p>
<p class="calibre1">serverSocket.close();</p>
<p class="calibre1">} catch (IOException ignore) {</p>
<p class="calibre1">}</p>
<p class="calibre1">}</p>
<p class="calibre1">}</p>
<p class="calibre1"><b class="calibre3">Listing A-5 </b></p>
<p class="calibre1"><b class="calibre3">MessageUtils.java</b></p>
<p class="calibre1">package common;</p>
<p class="calibre1">import java.io.IOException;</p>
<p class="calibre1">import java.io.InputStream;</p>
<p class="calibre1">import java.io.ObjectInputStream;</p>
<p class="calibre1">import java.io.ObjectOutputStream;</p>
<p class="calibre1">import java.io.OutputStream;</p>
<p class="calibre1">import java.net.Socket;</p>
<p class="calibre1">public class MessageUtils {</p>
<p class="calibre1">public static void sendMessage(Socket socket, String message)</p>
<p class="calibre1">throws IOException {</p>
<p class="calibre1">OutputStream stream = socket.getOutputStream();</p>
<p class="calibre1">ObjectOutputStream oos = new ObjectOutputStream(stream);</p>
<p class="calibre1">oos.writeUTF(message);</p>
<p class="calibre1">oos.flush();</p>
<p class="calibre1">}</p>
<p class="calibre1">public static String getMessage(Socket socket) throws IOException {</p>
<p class="calibre1">InputStream stream = socket.getInputStream();</p>
<p class="calibre1">ObjectInputStream ois = new ObjectInputStream(stream);</p>
<p class="calibre1">return ois.readUTF();</p>
<p class="calibre1">}</p>
<p class="calibre1">}</p>
<p class="calibre1"><a href="index_split_000.html#p18"><b class="calibre3">Client/Server Using Threads</b></a></p>
<p class="calibre1">Changing the server to use threads simply requires a change to the process message (new lines are emphasized to stand out):</p>
<p class="calibre1">void process(final Socket socket) {</p>
<p class="calibre1">if (socket == null)</p>
<p class="calibre1">return;</p>
<p class="calibre1"><b class="calibre3">    Runnable clientHandler = new Runnable() {</b></p>
<p class="calibre1">public void run() {</p>
<p class="calibre1"><a id="p378"></a><b class="calibre3">Tutorial: Full Code Examples</b></p>
<p class="calibre1">347</p>
<p class="calibre1">try {</p>
<p class="calibre1">System.out.printf("Server: getting message\n");</p>
<p class="calibre1">String message = MessageUtils.getMessage(socket);</p>
<p class="calibre1">System.out.printf("Server: got message: %s\n", message); Thread.sleep(1000);</p>
<p class="calibre1">System.out.printf("Server: sending reply: %s\n", message); MessageUtils.sendMessage(socket, "Processed: " + message); System.out.printf("Server: sent\n");</p>
<p class="calibre1">closeIgnoringException(socket);</p>
<p class="calibre1">} catch (Exception e) {</p>
<p class="calibre1">e.printStackTrace();</p>
<p class="calibre1">}</p>
<p class="calibre1">}</p>
<p class="calibre1">};</p>
<p class="calibre1"><b class="calibre3">    Thread clientConnection = new Thread(clientHandler); </b></p>
<p class="calibre1"><b class="calibre3">    clientConnection.start(); </b></p>
<p class="calibre1">}</p>
<p class="calibre1"><a id="p379"></a> <i class="calibre4">This page intentionally left blank </i></p>
<p class="calibre1"><a id="p380"></a><a href="index_split_000.html#p18"><b class="calibre3">Appendix B</b></a></p>
<p class="calibre1"><a href="index_split_000.html#p18"><b class="calibre3">org.jfree.date.SerialDate</b></a></p>
<p class="calibre1"><b class="calibre3">Listing B-1 </b></p>
<p class="calibre1"><b class="calibre3">SerialDate.Java</b></p>
<p class="calibre1">1 /* ========================================================================</p>
<p class="calibre1">2  * JCommon : a free general purpose class library for the Java(tm) platform 3  * ========================================================================</p>
<p class="calibre1">4  *</p>
<p class="calibre1">5  * (C) Copyright 2000-2005, by Object Refinery Limited and Contributors.</p>
<p class="calibre1">6  *</p>
<p class="calibre1">7  * Project Info:  http://www.jfree.org/jcommon/index.html</p>
<p class="calibre1">8  *</p>
<p class="calibre1">9  * This library is free software; you can redistribute it and/or modify it 10  * under the terms of the GNU Lesser General Public License as published by 11  * the Free Software Foundation; either version 2.1 of the License, or 12  * (at your option) any later version.</p>
<p class="calibre1">13  *</p>
<p class="calibre1">14  * This library is distributed in the hope that it will be useful, but 15  * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY</p>
<p class="calibre1">16  * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public 17  * License for more details.</p>
<p class="calibre1">18  *</p>
<p class="calibre1">19  * You should have received a copy of the GNU Lesser General Public 20  * License along with this library; if not, write to the Free Software 21  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, 22  * USA.</p>
<p class="calibre1">23  *</p>
<p class="calibre1">24  * [Java is a trademark or registered trademark of Sun Microsystems, Inc.</p>
<p class="calibre1">25  * in the United States and other countries.]</p>
<p class="calibre1">26  *</p>
<p class="calibre1">27  * ---------------</p>
<p class="calibre1">28  * SerialDate.java</p>
<p class="calibre1">29  * ---------------</p>
<p class="calibre1">30  * (C) Copyright 2001-2005, by Object Refinery Limited.</p>
<p class="calibre1">31  *</p>
<p class="calibre1">32  * Original Author:  David Gilbert (for Object Refinery Limited); 33  * Contributor(s):   -;</p>
<p class="calibre1">34  *</p>
<p class="calibre1">35  * $Id: SerialDate.java,v 1.7 2005/11/03 09:25:17 mungady Exp $</p>
<p class="calibre1">36  *</p>
<p class="calibre1">37  * Changes (from 11-Oct-2001)</p>
<p class="calibre1">349</p>
<p class="calibre1"><a id="p381"></a>350</p>
<p class="calibre1"><b class="calibre3">Appendix B: org.jfree.date.SerialDate</b></p>
<p class="calibre1"><b class="calibre3">Listing B-1 (continued)</b></p>
<p class="calibre1"><b class="calibre3">SerialDate.Java</b></p>
<p class="calibre1">38  * --------------------------</p>
<p class="calibre1">39  * 11-Oct-2001 : Re-organised the class and moved it to new package 40  *               com.jrefinery.date (DG);</p>
<p class="calibre1">41  * 05-Nov-2001 : Added a getDescription() method, and eliminated NotableDate 42  *               class (DG);</p>
<p class="calibre1">43  * 12-Nov-2001 : IBD requires setDescription() method, now that NotableDate 44  *               class is gone (DG);  Changed getPreviousDayOfWeek(), 45  *               getFollowingDayOfWeek() and getNearestDayOfWeek() to correct 46  *               bugs (DG); 47  * 05-Dec-2001 : Fixed bug in SpreadsheetDate class (DG);</p>
<p class="calibre1">48  * 29-May-2002 : Moved the month constants into a separate interface 49  *               (MonthConstants) (DG);</p>
<p class="calibre1">50  * 27-Aug-2002 : Fixed bug in addMonths() method, thanks to N???levka Petr (DG); 51  * 03-Oct-2002 : Fixed errors reported by Checkstyle (DG);</p>
<p class="calibre1">52  * 13-Mar-2003 : Implemented Serializable (DG);</p>
<p class="calibre1">53  * 29-May-2003 : Fixed bug in addMonths method (DG);</p>
<p class="calibre1">54  * 04-Sep-2003 : Implemented Comparable.  Updated the isInRange javadocs (DG); 55  * 05-Jan-2005 : Fixed bug in addYears() method (1096282) (DG); 56  *</p>
<p class="calibre1">57  */</p>
<p class="calibre1">58</p>
<p class="calibre1">59 package org.jfree.date;</p>
<p class="calibre1">60</p>
<p class="calibre1">61 import java.io.Serializable;</p>
<p class="calibre1">62 import java.text.DateFormatSymbols;</p>
<p class="calibre1">63 import java.text.SimpleDateFormat;</p>
<p class="calibre1">64 import java.util.Calendar;</p>
<p class="calibre1">65 import java.util.GregorianCalendar;</p>
<p class="calibre1">66</p>
<p class="calibre1">67 /**</p>
<p class="calibre1">68  *  An abstract class that defines our requirements for manipulating dates, 69  *  without tying down a particular implementation.</p>
<p class="calibre1">70  *  &lt;P&gt;</p>
<p class="calibre1">71  *  Requirement 1 : match at least what Excel does for dates; 72  *  Requirement 2 : class is immutable;</p>
<p class="calibre1">73  *  &lt;P&gt;</p>
<p class="calibre1">74  *  Why not just use java.util.Date?  We will, when it makes sense.  At times, 75  *  java.util.Date can be *too* precise - it represents an instant in time, 76  *  accurate to 1/1000th of a second (with the date itself depending on the 77  *  time-zone).  Sometimes we just want to represent a particular day (e.g. 21</p>
<p class="calibre1">78  *  January 2015) without concerning ourselves about the time of day, or the 79  *  time-zone, or anything else.  That's what we've defined SerialDate for.</p>
<p class="calibre1">80  *  &lt;P&gt;</p>
<p class="calibre1">81  *  You can call getInstance() to get a concrete subclass of SerialDate, 82  *  without worrying about the exact implementation.</p>
<p class="calibre1">83  *</p>
<p class="calibre1">84  * @author David Gilbert</p>
<p class="calibre1">85  */</p>
<p class="calibre1">86 public abstract class SerialDate implements Comparable,</p>
<p class="calibre1">87                                             Serializable,</p>
<p class="calibre1">88                                             MonthConstants {</p>
<p class="calibre1">89</p>
<p class="calibre1">90     /** For serialization. */</p>
<p class="calibre1">91     private static final long serialVersionUID = -293716040467423637L; 92</p>
<p class="calibre1">93     /** Date format symbols. */</p>
<p class="calibre1">94     public static final DateFormatSymbols</p>
<p class="calibre1">95         DATE_FORMAT_SYMBOLS = new SimpleDateFormat().getDateFormatSymbols(); 96</p>
<p class="calibre1">97     /** The serial number for 1 January 1900. */</p>
<p class="calibre1">98     public static final int SERIAL_LOWER_BOUND = 2;</p>
<p class="calibre1">99</p>
<p class="calibre1">100     /** The serial number for 31 December 9999. */</p>
<p class="calibre1">101     public static final int SERIAL_UPPER_BOUND = 2958465;</p>
<p class="calibre1">102</p>
<p class="calibre1"><a id="p382"></a><b class="calibre3">Appendix B: org.jfree.date.SerialDate</b></p>
<p class="calibre1">351</p>
<p class="calibre1"><b class="calibre3">Listing B-1 (continued)</b></p>
<p class="calibre1"><b class="calibre3">SerialDate.Java</b></p>
<p class="calibre1">103     /** The lowest year value supported by this date format. */</p>
<p class="calibre1">104     public static final int MINIMUM_YEAR_SUPPORTED = 1900; 105</p>
<p class="calibre1">106     /** The highest year value supported by this date format. */</p>
<p class="calibre1">107     public static final int MAXIMUM_YEAR_SUPPORTED = 9999; 108</p>
<p class="calibre1">109     /** Useful constant for Monday. Equivalent to java.util.Calendar.MONDAY. */</p>
<p class="calibre1">110     public static final int MONDAY = Calendar.MONDAY;</p>
<p class="calibre1">111</p>
<p class="calibre1">112     /**</p>
<p class="calibre1">113      * Useful constant for Tuesday. Equivalent to java.util.Calendar.TUESDAY.</p>
<p class="calibre1">114      */</p>
<p class="calibre1">115     public static final int TUESDAY = Calendar.TUESDAY;</p>
<p class="calibre1">116</p>
<p class="calibre1">117     /**</p>
<p class="calibre1">118      * Useful constant for Wednesday. Equivalent to</p>
<p class="calibre1">119      * java.util.Calendar.WEDNESDAY.</p>
<p class="calibre1">120      */</p>
<p class="calibre1">121     public static final int WEDNESDAY = Calendar.WEDNESDAY; 122</p>
<p class="calibre1">123     /**</p>
<p class="calibre1">124      * Useful constant for Thrusday. Equivalent to java.util.Calendar.THURSDAY.</p>
<p class="calibre1">125      */</p>
<p class="calibre1">126     public static final int THURSDAY = Calendar.THURSDAY;</p>
<p class="calibre1">127</p>
<p class="calibre1">128     /** Useful constant for Friday. Equivalent to java.util.Calendar.FRIDAY. */</p>
<p class="calibre1">129     public static final int FRIDAY = Calendar.FRIDAY;</p>
<p class="calibre1">130</p>
<p class="calibre1">131     /**</p>
<p class="calibre1">132      * Useful constant for Saturday. Equivalent to java.util.Calendar.SATURDAY.</p>
<p class="calibre1">133      */</p>
<p class="calibre1">134     public static final int SATURDAY = Calendar.SATURDAY;</p>
<p class="calibre1">135</p>
<p class="calibre1">136     /** Useful constant for Sunday. Equivalent to java.util.Calendar.SUNDAY. */</p>
<p class="calibre1">137     public static final int SUNDAY = Calendar.SUNDAY;</p>
<p class="calibre1">138</p>
<p class="calibre1">139     /** The number of days in each month in non leap years. */</p>
<p class="calibre1">140     static final int[] LAST_DAY_OF_MONTH =</p>
<p class="calibre1">141         {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; 142</p>
<p class="calibre1">143     /** The number of days in a (non-leap) year up to the end of each month. */</p>
<p class="calibre1">144     static final int[] AGGREGATE_DAYS_TO_END_OF_MONTH =</p>
<p class="calibre1">145         {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365}; 146</p>
<p class="calibre1">147     /** The number of days in a year up to the end of the preceding month. */</p>
<p class="calibre1">148     static final int[] AGGREGATE_DAYS_TO_END_OF_PRECEDING_MONTH =</p>
<p class="calibre1">149         {0, 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365}; 150</p>
<p class="calibre1">151     /** The number of days in a leap year up to the end of each month. */</p>
<p class="calibre1">152     static final int[] LEAP_YEAR_AGGREGATE_DAYS_TO_END_OF_MONTH =</p>
<p class="calibre1">153         {0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366}; 154</p>
<p class="calibre1">155     /**</p>
<p class="calibre1">156      * The number of days in a leap year up to the end of the preceding month.</p>
<p class="calibre1">157      */</p>
<p class="calibre1">158     static final int[]</p>
<p class="calibre1">159         LEAP_YEAR_AGGREGATE_DAYS_TO_END_OF_PRECEDING_MONTH =</p>
<p class="calibre1">160             {0, 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366}; 161</p>
<p class="calibre1">162     /** A useful constant for referring to the first week in a month. */</p>
<p class="calibre1">163     public static final int FIRST_WEEK_IN_MONTH = 1;</p>
<p class="calibre1">164</p>
<p class="calibre1"><a id="p383"></a>352</p>
<p class="calibre1"><b class="calibre3">Appendix B: org.jfree.date.SerialDate</b></p>
<p class="calibre1"><b class="calibre3">Listing B-1 (continued)</b></p>
<p class="calibre1"><b class="calibre3">SerialDate.Java</b></p>
<p class="calibre1">165     /** A useful constant for referring to the second week in a month. */</p>
<p class="calibre1">166     public static final int SECOND_WEEK_IN_MONTH = 2;</p>
<p class="calibre1">167</p>
<p class="calibre1">168     /** A useful constant for referring to the third week in a month. */</p>
<p class="calibre1">169     public static final int THIRD_WEEK_IN_MONTH = 3;</p>
<p class="calibre1">170</p>
<p class="calibre1">171     /** A useful constant for referring to the fourth week in a month. */</p>
<p class="calibre1">172     public static final int FOURTH_WEEK_IN_MONTH = 4;</p>
<p class="calibre1">173</p>
<p class="calibre1">174     /** A useful constant for referring to the last week in a month. */</p>
<p class="calibre1">175     public static final int LAST_WEEK_IN_MONTH = 0;</p>
<p class="calibre1">176</p>
<p class="calibre1">177     /** Useful range constant. */</p>
<p class="calibre1">178     public static final int INCLUDE_NONE = 0;</p>
<p class="calibre1">179</p>
<p class="calibre1">180     /** Useful range constant. */</p>
<p class="calibre1">181     public static final int INCLUDE_FIRST = 1;</p>
<p class="calibre1">182</p>
<p class="calibre1">183     /** Useful range constant. */</p>
<p class="calibre1">184     public static final int INCLUDE_SECOND = 2;</p>
<p class="calibre1">185</p>
<p class="calibre1">186     /** Useful range constant. */</p>
<p class="calibre1">187     public static final int INCLUDE_BOTH = 3;</p>
<p class="calibre1">188</p>
<p class="calibre1">189     /**</p>
<p class="calibre1">190      * Useful constant for specifying a day of the week relative to a fixed 191      * date.</p>
<p class="calibre1">192      */</p>
<p class="calibre1">193     public static final int PRECEDING = -1;</p>
<p class="calibre1">194</p>
<p class="calibre1">195     /**</p>
<p class="calibre1">196      * Useful constant for specifying a day of the week relative to a fixed 197      * date.</p>
<p class="calibre1">198      */</p>
<p class="calibre1">199     public static final int NEAREST = 0;</p>
<p class="calibre1">200</p>
<p class="calibre1">201     /**</p>
<p class="calibre1">202      * Useful constant for specifying a day of the week relative to a fixed 203      * date.</p>
<p class="calibre1">204      */</p>
<p class="calibre1">205     public static final int FOLLOWING = 1;</p>
<p class="calibre1">206</p>
<p class="calibre1">207     /** A description for the date. */</p>
<p class="calibre1">208     private String description;</p>
<p class="calibre1">209</p>
<p class="calibre1">210     /**</p>
<p class="calibre1">211      * Default constructor.</p>
<p class="calibre1">212      */</p>
<p class="calibre1">213     protected SerialDate() {</p>
<p class="calibre1">214     }</p>
<p class="calibre1">215</p>
<p class="calibre1">216     /**</p>
<p class="calibre1">217      * Returns &lt;code&gt;true&lt;/code&gt; if the supplied integer code represents a 218      * valid day-of-the-week, and &lt;code&gt;false&lt;/code&gt; otherwise.</p>
<p class="calibre1">219      *</p>
<p class="calibre1">220      * @param code  the code being checked for validity.</p>
<p class="calibre1">221      *</p>
<p class="calibre1">222      * @return &lt;code&gt;true&lt;/code&gt; if the supplied integer code represents a 223      *         valid day-of-the-week, and &lt;code&gt;false&lt;/code&gt; otherwise.</p>
<p class="calibre1">224      */</p>
<p class="calibre1">225     public static boolean isValidWeekdayCode(final int code) {</p>
<p class="calibre1">226</p>
<p class="calibre1"><a id="p384"></a><b class="calibre3">Appendix B: org.jfree.date.SerialDate</b></p>
<p class="calibre1">353</p>
<p class="calibre1"><b class="calibre3">Listing B-1 (continued)</b></p>
<p class="calibre1"><b class="calibre3">SerialDate.Java</b></p>
<p class="calibre1">227         switch(code) {</p>
<p class="calibre1">228             case SUNDAY:</p>
<p class="calibre1">229             case MONDAY:</p>
<p class="calibre1">230             case TUESDAY:</p>
<p class="calibre1">231             case WEDNESDAY:</p>
<p class="calibre1">232             case THURSDAY:</p>
<p class="calibre1">233             case FRIDAY:</p>
<p class="calibre1">234             case SATURDAY:</p>
<p class="calibre1">235                 return true;</p>
<p class="calibre1">236             default:</p>
<p class="calibre1">237                 return false;</p>
<p class="calibre1">238         }</p>
<p class="calibre1">239</p>
<p class="calibre1">240     }</p>
<p class="calibre1">241</p>
<p class="calibre1">242     /**</p>
<p class="calibre1">243      * Converts the supplied string to a day of the week.</p>
<p class="calibre1">244      *</p>
<p class="calibre1">245      * @param s  a string representing the day of the week.</p>
<p class="calibre1">246      *</p>
<p class="calibre1">247      * @return &lt;code&gt;-1&lt;/code&gt; if the string is not convertable, the day of 248      *         the week otherwise.</p>
<p class="calibre1">249      */</p>
<p class="calibre1">250     public static int stringToWeekdayCode(String s) {</p>
<p class="calibre1">251</p>
<p class="calibre1">252         final String[] shortWeekdayNames</p>
<p class="calibre1">253             = DATE_FORMAT_SYMBOLS.getShortWeekdays();</p>
<p class="calibre1">254         final String[] weekDayNames = DATE_FORMAT_SYMBOLS.getWeekdays(); 255</p>
<p class="calibre1">256         int result = -1;</p>
<p class="calibre1">257         s = s.trim();</p>
<p class="calibre1">258         for (int i = 0; i &lt; weekDayNames.length; i++) {</p>
<p class="calibre1">259             if (s.equals(shortWeekdayNames[i])) {</p>
<p class="calibre1">260                 result = i;</p>
<p class="calibre1">261                 break;</p>
<p class="calibre1">262             }</p>
<p class="calibre1">263             if (s.equals(weekDayNames[i])) {</p>
<p class="calibre1">264                 result = i;</p>
<p class="calibre1">265                 break;</p>
<p class="calibre1">266             }</p>
<p class="calibre1">267         }</p>
<p class="calibre1">268         return result;</p>
<p class="calibre1">269</p>
<p class="calibre1">270     }</p>
<p class="calibre1">271</p>
<p class="calibre1">272     /**</p>
<p class="calibre1">273      * Returns a string representing the supplied day-of-the-week.</p>
<p class="calibre1">274      * &lt;P&gt;</p>
<p class="calibre1">275      * Need to find a better approach.</p>
<p class="calibre1">276      *</p>
<p class="calibre1">277      * @param weekday  the day of the week.</p>
<p class="calibre1">278      *</p>
<p class="calibre1">279      * @return a string representing the supplied day-of-the-week.</p>
<p class="calibre1">280      */</p>
<p class="calibre1">281     public static String weekdayCodeToString(final int weekday) {</p>
<p class="calibre1">282</p>
<p class="calibre1">283         final String[] weekdays = DATE_FORMAT_SYMBOLS.getWeekdays(); 284         return weekdays[weekday];</p>
<p class="calibre1">285</p>
<p class="calibre1">286     }</p>
<p class="calibre1">287</p>
<p class="calibre1">288     /**</p>
<p class="calibre1"><a id="p385"></a>354</p>
<p class="calibre1"><b class="calibre3">Appendix B: org.jfree.date.SerialDate</b></p>
<p class="calibre1"><b class="calibre3">Listing B-1 (continued)</b></p>
<p class="calibre1"><b class="calibre3">SerialDate.Java</b></p>
<p class="calibre1">289      * Returns an array of month names.</p>
<p class="calibre1">290      *</p>
<p class="calibre1">291      * @return an array of month names.</p>
<p class="calibre1">292      */</p>
<p class="calibre1">293     public static String[] getMonths() {</p>
<p class="calibre1">294</p>
<p class="calibre1">295         return getMonths(false);</p>
<p class="calibre1">296</p>
<p class="calibre1">297     }</p>
<p class="calibre1">298</p>
<p class="calibre1">299     /**</p>
<p class="calibre1">300      * Returns an array of month names.</p>
<p class="calibre1">301      *</p>
<p class="calibre1">302      * @param shortened  a flag indicating that shortened month names should 303      *                   be returned.</p>
<p class="calibre1">304      *</p>
<p class="calibre1">305      * @return an array of month names.</p>
<p class="calibre1">306      */</p>
<p class="calibre1">307     public static String[] getMonths(final boolean shortened) {</p>
<p class="calibre1">308</p>
<p class="calibre1">309         if (shortened) {</p>
<p class="calibre1">310             return DATE_FORMAT_SYMBOLS.getShortMonths();</p>
<p class="calibre1">311         }</p>
<p class="calibre1">312         else {</p>
<p class="calibre1">313             return DATE_FORMAT_SYMBOLS.getMonths();</p>
<p class="calibre1">314         }</p>
<p class="calibre1">315</p>
<p class="calibre1">316     }</p>
<p class="calibre1">317</p>
<p class="calibre1">318     /**</p>
<p class="calibre1">319      * Returns true if the supplied integer code represents a valid month.</p>
<p class="calibre1">320      *</p>
<p class="calibre1">321      * @param code  the code being checked for validity.</p>
<p class="calibre1">322      *</p>
<p class="calibre1">323      * @return &lt;code&gt;true&lt;/code&gt; if the supplied integer code represents a 324      *         valid month.</p>
<p class="calibre1">325      */</p>
<p class="calibre1">326     public static boolean isValidMonthCode(final int code) {</p>
<p class="calibre1">327</p>
<p class="calibre1">328         switch(code) {</p>
<p class="calibre1">329             case JANUARY:</p>
<p class="calibre1">330             case FEBRUARY:</p>
<p class="calibre1">331             case MARCH:</p>
<p class="calibre1">332             case APRIL:</p>
<p class="calibre1">333             case MAY:</p>
<p class="calibre1">334             case JUNE:</p>
<p class="calibre1">335             case JULY:</p>
<p class="calibre1">336             case AUGUST:</p>
<p class="calibre1">337             case SEPTEMBER:</p>
<p class="calibre1">338             case OCTOBER:</p>
<p class="calibre1">339             case NOVEMBER:</p>
<p class="calibre1">340             case DECEMBER:</p>
<p class="calibre1">341                 return true;</p>
<p class="calibre1">342             default:</p>
<p class="calibre1">343                 return false;</p>
<p class="calibre1">344         }</p>
<p class="calibre1">345</p>
<p class="calibre1">346     }</p>
<p class="calibre1">347</p>
<p class="calibre1">348     /**</p>
<p class="calibre1">349      * Returns the quarter for the specified month.</p>
<p class="calibre1">350      *</p>
<p class="calibre1"><a id="p386"></a><b class="calibre3">Appendix B: org.jfree.date.SerialDate</b></p>
<p class="calibre1">355</p>
<p class="calibre1"><b class="calibre3">Listing B-1 (continued)</b></p>
<p class="calibre1"><b class="calibre3">SerialDate.Java</b></p>
<p class="calibre1">351      * @param code  the month code (1-12).</p>
<p class="calibre1">352      *</p>
<p class="calibre1">353      * @return the quarter that the month belongs to.</p>
<p class="calibre1">354      * @throws java.lang.IllegalArgumentException</p>
<p class="calibre1">355      */</p>
<p class="calibre1">356     public static int monthCodeToQuarter(final int code) {</p>
<p class="calibre1">357</p>
<p class="calibre1">358         switch(code) {</p>
<p class="calibre1">359             case JANUARY:</p>
<p class="calibre1">360             case FEBRUARY:</p>
<p class="calibre1">361             case MARCH: return 1;</p>
<p class="calibre1">362             case APRIL:</p>
<p class="calibre1">363             case MAY:</p>
<p class="calibre1">364             case JUNE: return 2;</p>
<p class="calibre1">365             case JULY:</p>
<p class="calibre1">366             case AUGUST:</p>
<p class="calibre1">367             case SEPTEMBER: return 3;</p>
<p class="calibre1">368             case OCTOBER:</p>
<p class="calibre1">369             case NOVEMBER:</p>
<p class="calibre1">370             case DECEMBER: return 4;</p>
<p class="calibre1">371             default: throw new IllegalArgumentException(</p>
<p class="calibre1">372                 "SerialDate.monthCodeToQuarter: invalid month code."); 373         }</p>
<p class="calibre1">374</p>
<p class="calibre1">375     }</p>
<p class="calibre1">376</p>
<p class="calibre1">377     /**</p>
<p class="calibre1">378      * Returns a string representing the supplied month.</p>
<p class="calibre1">379      * &lt;P&gt;</p>
<p class="calibre1">380      * The string returned is the long form of the month name taken from the 381      * default locale.</p>
<p class="calibre1">382      *</p>
<p class="calibre1">383      * @param month  the month.</p>
<p class="calibre1">384      *</p>
<p class="calibre1">385      * @return a string representing the supplied month.</p>
<p class="calibre1">386      */</p>
<p class="calibre1">387     public static String monthCodeToString(final int month) {</p>
<p class="calibre1">388</p>
<p class="calibre1">389         return monthCodeToString(month, false);</p>
<p class="calibre1">390</p>
<p class="calibre1">391     }</p>
<p class="calibre1">392</p>
<p class="calibre1">393     /**</p>
<p class="calibre1">394      * Returns a string representing the supplied month.</p>
<p class="calibre1">395      * &lt;P&gt;</p>
<p class="calibre1">396      * The string returned is the long or short form of the month name taken 397      * from the default locale.</p>
<p class="calibre1">398      *</p>
<p class="calibre1">399      * @param month  the month.</p>
<p class="calibre1">400      * @param shortened  if &lt;code&gt;true&lt;/code&gt; return the abbreviation of the 401      *                   month.</p>
<p class="calibre1">402      *</p>
<p class="calibre1">403      * @return a string representing the supplied month.</p>
<p class="calibre1">404      * @throws java.lang.IllegalArgumentException</p>
<p class="calibre1">405      */</p>
<p class="calibre1">406     public static String monthCodeToString(final int month, 407                                            final boolean shortened) {</p>
<p class="calibre1">408</p>
<p class="calibre1">409         // check arguments...</p>
<p class="calibre1">410         if (!isValidMonthCode(month)) {</p>
<p class="calibre1">411             throw new IllegalArgumentException(</p>
<p class="calibre1">412                 "SerialDate.monthCodeToString: month outside valid range.");</p>
<p class="calibre1"><a id="p387"></a>356</p>
<p class="calibre1"><b class="calibre3">Appendix B: org.jfree.date.SerialDate</b></p>
<p class="calibre1"><b class="calibre3">Listing B-1 (continued)</b></p>
<p class="calibre1"><b class="calibre3">SerialDate.Java</b></p>
<p class="calibre1">413         }</p>
<p class="calibre1">414</p>
<p class="calibre1">415         final String[] months;</p>
<p class="calibre1">416</p>
<p class="calibre1">417         if (shortened) {</p>
<p class="calibre1">418             months = DATE_FORMAT_SYMBOLS.getShortMonths(); 419         }</p>
<p class="calibre1">420         else {</p>
<p class="calibre1">421             months = DATE_FORMAT_SYMBOLS.getMonths();</p>
<p class="calibre1">422         }</p>
<p class="calibre1">423</p>
<p class="calibre1">424         return months[month - 1];</p>
<p class="calibre1">425</p>
<p class="calibre1">426     }</p>
<p class="calibre1">427</p>
<p class="calibre1">428     /**</p>
<p class="calibre1">429      * Converts a string to a month code.</p>
<p class="calibre1">430      * &lt;P&gt;</p>
<p class="calibre1">431      * This method will return one of the constants JANUARY, FEBRUARY, ..., 432      * DECEMBER that corresponds to the string.  If the string is not 433      * recognised, this method returns -1.</p>
<p class="calibre1">434      *</p>
<p class="calibre1">435      * @param s  the string to parse.</p>
<p class="calibre1">436      *</p>
<p class="calibre1">437      * @return &lt;code&gt;-1&lt;/code&gt; if the string is not parseable, the month of the 438      *         year otherwise.</p>
<p class="calibre1">439      */</p>
<p class="calibre1">440     public static int stringToMonthCode(String s) {</p>
<p class="calibre1">441</p>
<p class="calibre1">442         final String[] shortMonthNames = DATE_FORMAT_SYMBOLS.getShortMonths(); 443         final String[] monthNames = DATE_FORMAT_SYMBOLS.getMonths(); 444</p>
<p class="calibre1">445         int result = -1;</p>
<p class="calibre1">446         s = s.trim();</p>
<p class="calibre1">447</p>
<p class="calibre1">448         // first try parsing the string as an integer (1-12)...</p>
<p class="calibre1">449         try {</p>
<p class="calibre1">450             result = Integer.parseInt(s);</p>
<p class="calibre1">451         }</p>
<p class="calibre1">452         catch (NumberFormatException e) {</p>
<p class="calibre1">453             // suppress</p>
<p class="calibre1">454         }</p>
<p class="calibre1">455</p>
<p class="calibre1">456         // now search through the month names...</p>
<p class="calibre1">457         if ((result &lt; 1) || (result &gt; 12)) {</p>
<p class="calibre1">458             for (int i = 0; i &lt; monthNames.length; i++) {</p>
<p class="calibre1">459                 if (s.equals(shortMonthNames[i])) {</p>
<p class="calibre1">460                     result = i + 1;</p>
<p class="calibre1">461                     break;</p>
<p class="calibre1">462                 }</p>
<p class="calibre1">463                 if (s.equals(monthNames[i])) {</p>
<p class="calibre1">464                     result = i + 1;</p>
<p class="calibre1">465                     break;</p>
<p class="calibre1">466                 }</p>
<p class="calibre1">467             }</p>
<p class="calibre1">468         }</p>
<p class="calibre1">469</p>
<p class="calibre1">470         return result;</p>
<p class="calibre1">471</p>
<p class="calibre1">472     }</p>
<p class="calibre1">473</p>
<p class="calibre1">474     /**</p>
<p class="calibre1"><a id="p388"></a><b class="calibre3">Appendix B: org.jfree.date.SerialDate</b></p>
<p class="calibre1">357</p>
<p class="calibre1"><b class="calibre3">Listing B-1 (continued)</b></p>
<p class="calibre1"><b class="calibre3">SerialDate.Java</b></p>
<p class="calibre1">475      * Returns true if the supplied integer code represents a valid 476      * week-in-the-month, and false otherwise.</p>
<p class="calibre1">477      *</p>
<p class="calibre1">478      * @param code  the code being checked for validity.</p>
<p class="calibre1">479      * @return &lt;code&gt;true&lt;/code&gt; if the supplied integer code represents a 480      *         valid week-in-the-month.</p>
<p class="calibre1">481      */</p>
<p class="calibre1">482     public static boolean isValidWeekInMonthCode(final int code) {</p>
<p class="calibre1">483</p>
<p class="calibre1">484         switch(code) {</p>
<p class="calibre1">485             case FIRST_WEEK_IN_MONTH:</p>
<p class="calibre1">486             case SECOND_WEEK_IN_MONTH:</p>
<p class="calibre1">487             case THIRD_WEEK_IN_MONTH:</p>
<p class="calibre1">488             case FOURTH_WEEK_IN_MONTH:</p>
<p class="calibre1">489             case LAST_WEEK_IN_MONTH: return true;</p>
<p class="calibre1">490             default: return false;</p>
<p class="calibre1">491         }</p>
<p class="calibre1">492</p>
<p class="calibre1">493     }</p>
<p class="calibre1">494</p>
<p class="calibre1">495     /**</p>
<p class="calibre1">496      * Determines whether or not the specified year is a leap year.</p>
<p class="calibre1">497      *</p>
<p class="calibre1">498      * @param yyyy  the year (in the range 1900 to 9999).</p>
<p class="calibre1">499      *</p>
<p class="calibre1">500      * @return &lt;code&gt;true&lt;/code&gt; if the specified year is a leap year.</p>
<p class="calibre1">501      */</p>
<p class="calibre1">502     public static boolean isLeapYear(final int yyyy) {</p>
<p class="calibre1">503</p>
<p class="calibre1">504         if ((yyyy % 4) != 0) {</p>
<p class="calibre1">505             return false;</p>
<p class="calibre1">506         }</p>
<p class="calibre1">507         else if ((yyyy % 400) == 0) {</p>
<p class="calibre1">508             return true;</p>
<p class="calibre1">509         }</p>
<p class="calibre1">510         else if ((yyyy % 100) == 0) {</p>
<p class="calibre1">511             return false;</p>
<p class="calibre1">512         }</p>
<p class="calibre1">513         else {</p>
<p class="calibre1">514             return true;</p>
<p class="calibre1">515         }</p>
<p class="calibre1">516</p>
<p class="calibre1">517     }</p>
<p class="calibre1">518</p>
<p class="calibre1">519     /**</p>
<p class="calibre1">520      * Returns the number of leap years from 1900 to the specified year 521      * INCLUSIVE.</p>
<p class="calibre1">522      * &lt;P&gt;</p>
<p class="calibre1">523      * Note that 1900 is not a leap year.</p>
<p class="calibre1">524      *</p>
<p class="calibre1">525      * @param yyyy  the year (in the range 1900 to 9999).</p>
<p class="calibre1">526      *</p>
<p class="calibre1">527      * @return the number of leap years from 1900 to the specified year.</p>
<p class="calibre1">528      */</p>
<p class="calibre1">529     public static int leapYearCount(final int yyyy) {</p>
<p class="calibre1">530</p>
<p class="calibre1">531         final int leap4 = (yyyy - 1896) / 4;</p>
<p class="calibre1">532         final int leap100 = (yyyy - 1800) / 100;</p>
<p class="calibre1">533         final int leap400 = (yyyy - 1600) / 400;</p>
<p class="calibre1">534         return leap4 - leap100 + leap400;</p>
<p class="calibre1">535</p>
<p class="calibre1">536     }</p>
<p class="calibre1"><a id="p389"></a>358</p>
<p class="calibre1"><b class="calibre3">Appendix B: org.jfree.date.SerialDate</b></p>
<p class="calibre1"><b class="calibre3">Listing B-1 (continued)</b></p>
<p class="calibre1"><b class="calibre3">SerialDate.Java</b></p>
<p class="calibre1">537</p>
<p class="calibre1">538     /**</p>
<p class="calibre1">539      * Returns the number of the last day of the month, taking into account 540      * leap years.</p>
<p class="calibre1">541      *</p>
<p class="calibre1">542      * @param month  the month.</p>
<p class="calibre1">543      * @param yyyy  the year (in the range 1900 to 9999).</p>
<p class="calibre1">544      *</p>
<p class="calibre1">545      * @return the number of the last day of the month.</p>
<p class="calibre1">546      */</p>
<p class="calibre1">547     public static int lastDayOfMonth(final int month, final int yyyy) {</p>
<p class="calibre1">548</p>
<p class="calibre1">549         final int result = LAST_DAY_OF_MONTH[month];</p>
<p class="calibre1">550         if (month != FEBRUARY) {</p>
<p class="calibre1">551             return result;</p>
<p class="calibre1">552         }</p>
<p class="calibre1">553         else if (isLeapYear(yyyy)) {</p>
<p class="calibre1">554             return result + 1;</p>
<p class="calibre1">555         }</p>
<p class="calibre1">556         else {</p>
<p class="calibre1">557             return result;</p>
<p class="calibre1">558         }</p>
<p class="calibre1">559</p>
<p class="calibre1">560     }</p>
<p class="calibre1">561</p>
<p class="calibre1">562     /**</p>
<p class="calibre1">563      * Creates a new date by adding the specified number of days to the base 564      * date.</p>
<p class="calibre1">565      *</p>
<p class="calibre1">566      * @param days  the number of days to add (can be negative).</p>
<p class="calibre1">567      * @param base  the base date.</p>
<p class="calibre1">568      *</p>
<p class="calibre1">569      * @return a new date.</p>
<p class="calibre1">570      */</p>
<p class="calibre1">571     public static SerialDate addDays(final int days, final SerialDate base) {</p>
<p class="calibre1">572</p>
<p class="calibre1">573         final int serialDayNumber = base.toSerial() + days; 574         return SerialDate.createInstance(serialDayNumber); 575</p>
<p class="calibre1">576     }</p>
<p class="calibre1">577</p>
<p class="calibre1">578     /**</p>
<p class="calibre1">579      * Creates a new date by adding the specified number of months to the base 580      * date.</p>
<p class="calibre1">581      * &lt;P&gt;</p>
<p class="calibre1">582      * If the base date is close to the end of the month, the day on the result 583      * may be adjusted slightly:  31 May + 1 month = 30 June.</p>
<p class="calibre1">584      *</p>
<p class="calibre1">585      * @param months  the number of months to add (can be negative).</p>
<p class="calibre1">586      * @param base  the base date.</p>
<p class="calibre1">587      *</p>
<p class="calibre1">588      * @return a new date.</p>
<p class="calibre1">589      */</p>
<p class="calibre1">590     public static SerialDate addMonths(final int months,</p>
<p class="calibre1">591                                        final SerialDate base) {</p>
<p class="calibre1">592</p>
<p class="calibre1">593         final int yy = (12 * base.getYYYY() + base.getMonth() + months - 1) 594                        / 12;</p>
<p class="calibre1">595         final int mm = (12 * base.getYYYY() + base.getMonth() + months - 1) 596                        % 12 + 1;</p>
<p class="calibre1">597         final int dd = Math.min(</p>
<p class="calibre1">598             base.getDayOfMonth(), SerialDate.lastDayOfMonth(mm, yy)</p>
<p class="calibre1"><a id="p390"></a><b class="calibre3">Appendix B: org.jfree.date.SerialDate</b></p>
<p class="calibre1">359</p>
<p class="calibre1"><b class="calibre3">Listing B-1 (continued)</b></p>
<p class="calibre1"><b class="calibre3">SerialDate.Java</b></p>
<p class="calibre1">599         );</p>
<p class="calibre1">600         return SerialDate.createInstance(dd, mm, yy);</p>
<p class="calibre1">601</p>
<p class="calibre1">602     }</p>
<p class="calibre1">603</p>
<p class="calibre1">604     /**</p>
<p class="calibre1">605      * Creates a new date by adding the specified number of years to the base 606      * date.</p>
<p class="calibre1">607      *</p>
<p class="calibre1">608      * @param years  the number of years to add (can be negative).</p>
<p class="calibre1">609      * @param base  the base date.</p>
<p class="calibre1">610      *</p>
<p class="calibre1">611      * @return A new date.</p>
<p class="calibre1">612      */</p>
<p class="calibre1">613     public static SerialDate addYears(final int years, final SerialDate base) {</p>
<p class="calibre1">614</p>
<p class="calibre1">615         final int baseY = base.getYYYY();</p>
<p class="calibre1">616         final int baseM = base.getMonth();</p>
<p class="calibre1">617         final int baseD = base.getDayOfMonth();</p>
<p class="calibre1">618</p>
<p class="calibre1">619         final int targetY = baseY + years;</p>
<p class="calibre1">620         final int targetD = Math.min(</p>
<p class="calibre1">621             baseD, SerialDate.lastDayOfMonth(baseM, targetY) 622         );</p>
<p class="calibre1">623</p>
<p class="calibre1">624         return SerialDate.createInstance(targetD, baseM, targetY); 625</p>
<p class="calibre1">626     }</p>
<p class="calibre1">627</p>
<p class="calibre1">628     /**</p>
<p class="calibre1">629      * Returns the latest date that falls on the specified day-of-the-week and 630      * is BEFORE the base date.</p>
<p class="calibre1">631      *</p>
<p class="calibre1">632      * @param targetWeekday  a code for the target day-of-the-week.</p>
<p class="calibre1">633      * @param base  the base date.</p>
<p class="calibre1">634      *</p>
<p class="calibre1">635      * @return the latest date that falls on the specified day-of-the-week and 636      *         is BEFORE the base date.</p>
<p class="calibre1">637      */</p>
<p class="calibre1">638     public static SerialDate getPreviousDayOfWeek(final int targetWeekday, 639                                                   final SerialDate base) {</p>
<p class="calibre1">640</p>
<p class="calibre1">641         // check arguments...</p>
<p class="calibre1">642         if (!SerialDate.isValidWeekdayCode(targetWeekday)) {</p>
<p class="calibre1">643             throw new IllegalArgumentException(</p>
<p class="calibre1">644                 "Invalid day-of-the-week code."</p>
<p class="calibre1">645             );</p>
<p class="calibre1">646         }</p>
<p class="calibre1">647</p>
<p class="calibre1">648         // find the date...</p>
<p class="calibre1">649         final int adjust;</p>
<p class="calibre1">650         final int baseDOW = base.getDayOfWeek();</p>
<p class="calibre1">651         if (baseDOW &gt; targetWeekday) {</p>
<p class="calibre1">652             adjust = Math.min(0, targetWeekday - baseDOW); 653         }</p>
<p class="calibre1">654         else {</p>
<p class="calibre1">655             adjust = -7 + Math.max(0, targetWeekday - baseDOW); 656         }</p>
<p class="calibre1">657</p>
<p class="calibre1">658         return SerialDate.addDays(adjust, base);</p>
<p class="calibre1">659</p>
<p class="calibre1">660     }</p>
<p class="calibre1"><a id="p391"></a>360</p>
<p class="calibre1"><b class="calibre3">Appendix B: org.jfree.date.SerialDate</b></p>
<p class="calibre1"><b class="calibre3">Listing B-1 (continued)</b></p>
<p class="calibre1"><b class="calibre3">SerialDate.Java</b></p>
<p class="calibre1">661</p>
<p class="calibre1">662     /**</p>
<p class="calibre1">663      * Returns the earliest date that falls on the specified day-of-the-week 664      * and is AFTER the base date.</p>
<p class="calibre1">665      *</p>
<p class="calibre1">666      * @param targetWeekday  a code for the target day-of-the-week.</p>
<p class="calibre1">667      * @param base  the base date.</p>
<p class="calibre1">668      *</p>
<p class="calibre1">669      * @return the earliest date that falls on the specified day-of-the-week 670      *         and is AFTER the base date.</p>
<p class="calibre1">671      */</p>
<p class="calibre1">672     public static SerialDate getFollowingDayOfWeek(final int targetWeekday, 673                                                    final SerialDate base) {</p>
<p class="calibre1">674</p>
<p class="calibre1">675         // check arguments...</p>
<p class="calibre1">676         if (!SerialDate.isValidWeekdayCode(targetWeekday)) {</p>
<p class="calibre1">677             throw new IllegalArgumentException(</p>
<p class="calibre1">678                 "Invalid day-of-the-week code."</p>
<p class="calibre1">679             );</p>
<p class="calibre1">680         }</p>
<p class="calibre1">681</p>
<p class="calibre1">682         // find the date...</p>
<p class="calibre1">683         final int adjust;</p>
<p class="calibre1">684         final int baseDOW = base.getDayOfWeek();</p>
<p class="calibre1">685         if (baseDOW &gt; targetWeekday) {</p>
<p class="calibre1">686             adjust = 7 + Math.min(0, targetWeekday - baseDOW); 687         }</p>
<p class="calibre1">688         else {</p>
<p class="calibre1">689             adjust = Math.max(0, targetWeekday - baseDOW); 690         }</p>
<p class="calibre1">691</p>
<p class="calibre1">692         return SerialDate.addDays(adjust, base);</p>
<p class="calibre1">693     }</p>
<p class="calibre1">694</p>
<p class="calibre1">695     /**</p>
<p class="calibre1">696      * Returns the date that falls on the specified day-of-the-week and is 697      * CLOSEST to the base date.</p>
<p class="calibre1">698      *</p>
<p class="calibre1">699      * @param targetDOW  a code for the target day-of-the-week.</p>
<p class="calibre1">700      * @param base  the base date.</p>
<p class="calibre1">701      *</p>
<p class="calibre1">702      * @return the date that falls on the specified day-of-the-week and is 703      *         CLOSEST to the base date.</p>
<p class="calibre1">704      */</p>
<p class="calibre1">705     public static SerialDate getNearestDayOfWeek(final int targetDOW, 706                                                  final SerialDate base) {</p>
<p class="calibre1">707</p>
<p class="calibre1">708         // check arguments...</p>
<p class="calibre1">709         if (!SerialDate.isValidWeekdayCode(targetDOW)) {</p>
<p class="calibre1">710             throw new IllegalArgumentException(</p>
<p class="calibre1">711                 "Invalid day-of-the-week code."</p>
<p class="calibre1">712             );</p>
<p class="calibre1">713         }</p>
<p class="calibre1">714</p>
<p class="calibre1">715         // find the date...</p>
<p class="calibre1">716         final int baseDOW = base.getDayOfWeek();</p>
<p class="calibre1">717         int adjust = -Math.abs(targetDOW - baseDOW);</p>
<p class="calibre1">718         if (adjust &gt;= 4) {</p>
<p class="calibre1">719             adjust = 7 - adjust;</p>
<p class="calibre1">720         }</p>
<p class="calibre1">721         if (adjust &lt;= -4) {</p>
<p class="calibre1">722             adjust = 7 + adjust;</p>
<p class="calibre1"><a id="p392"></a><b class="calibre3">Appendix B: org.jfree.date.SerialDate</b></p>
<p class="calibre1">361</p>
<p class="calibre1"><b class="calibre3">Listing B-1 (continued)</b></p>
<p class="calibre1"><b class="calibre3">SerialDate.Java</b></p>
<p class="calibre1">723         }</p>
<p class="calibre1">724         return SerialDate.addDays(adjust, base);</p>
<p class="calibre1">725</p>
<p class="calibre1">726     }</p>
<p class="calibre1">727</p>
<p class="calibre1">728     /**</p>
<p class="calibre1">729      * Rolls the date forward to the last day of the month.</p>
<p class="calibre1">730      *</p>
<p class="calibre1">731      * @param base  the base date.</p>
<p class="calibre1">732      *</p>
<p class="calibre1">733      * @return a new serial date.</p>
<p class="calibre1">734      */</p>
<p class="calibre1">735     public SerialDate getEndOfCurrentMonth(final SerialDate base) {</p>
<p class="calibre1">736         final int last = SerialDate.lastDayOfMonth(</p>
<p class="calibre1">737             base.getMonth(), base.getYYYY()</p>
<p class="calibre1">738         );</p>
<p class="calibre1">739         return SerialDate.createInstance(last, base.getMonth(), base.getYYYY()); 740     }</p>
<p class="calibre1">741</p>
<p class="calibre1">742     /**</p>
<p class="calibre1">743      * Returns a string corresponding to the week-in-the-month code.</p>
<p class="calibre1">744      * &lt;P&gt;</p>
<p class="calibre1">745      * Need to find a better approach.</p>
<p class="calibre1">746      *</p>
<p class="calibre1">747      * @param count  an integer code representing the week-in-the-month.</p>
<p class="calibre1">748      *</p>
<p class="calibre1">749      * @return a string corresponding to the week-in-the-month code.</p>
<p class="calibre1">750      */</p>
<p class="calibre1">751     public static String weekInMonthToString(final int count) {</p>
<p class="calibre1">752</p>
<p class="calibre1">753         switch (count) {</p>
<p class="calibre1">754             case SerialDate.FIRST_WEEK_IN_MONTH : return "First"; 755             case SerialDate.SECOND_WEEK_IN_MONTH : return "Second"; 756             case SerialDate.THIRD_WEEK_IN_MONTH : return "Third"; 757             case SerialDate.FOURTH_WEEK_IN_MONTH : return "Fourth"; 758             case SerialDate.LAST_WEEK_IN_MONTH : return "Last"; 759             default : 760                 return "SerialDate.weekInMonthToString(): invalid code."; 761         }</p>
<p class="calibre1">762</p>
<p class="calibre1">763     }</p>
<p class="calibre1">764</p>
<p class="calibre1">765     /**</p>
<p class="calibre1">766      * Returns a string representing the supplied 'relative'.</p>
<p class="calibre1">767      * &lt;P&gt;</p>
<p class="calibre1">768      * Need to find a better approach.</p>
<p class="calibre1">769      *</p>
<p class="calibre1">770      * @param relative  a constant representing the 'relative'.</p>
<p class="calibre1">771      *</p>
<p class="calibre1">772      * @return a string representing the supplied 'relative'.</p>
<p class="calibre1">773      */</p>
<p class="calibre1">774     public static String relativeToString(final int relative) {</p>
<p class="calibre1">775</p>
<p class="calibre1">776         switch (relative) {</p>
<p class="calibre1">777             case SerialDate.PRECEDING : return "Preceding"; 778             case SerialDate.NEAREST : return "Nearest"; 779             case SerialDate.FOLLOWING : return "Following"; 780             default : return "ERROR : Relative To String"; 781         }</p>
<p class="calibre1">782</p>
<p class="calibre1">783     }</p>
<p class="calibre1">784</p>
<p class="calibre1"><a id="p393"></a>362</p>
<p class="calibre1"><b class="calibre3">Appendix B: org.jfree.date.SerialDate</b></p>
<p class="calibre1"><b class="calibre3">Listing B-1 (continued)</b></p>
<p class="calibre1"><b class="calibre3">SerialDate.Java</b></p>
<p class="calibre1">785     /**</p>
<p class="calibre1">786      * Factory method that returns an instance of some concrete subclass of 787      * {@link SerialDate}.</p>
<p class="calibre1">788      *</p>
<p class="calibre1">789      * @param day  the day (1-31).</p>
<p class="calibre1">790      * @param month  the month (1-12).</p>
<p class="calibre1">791      * @param yyyy  the year (in the range 1900 to 9999).</p>
<p class="calibre1">792      *</p>
<p class="calibre1">793      * @return An instance of {@link SerialDate}.</p>
<p class="calibre1">794      */</p>
<p class="calibre1">795     public static SerialDate createInstance(final int day, final int month, 796                                             final int yyyy) {</p>
<p class="calibre1">797         return new SpreadsheetDate(day, month, yyyy);</p>
<p class="calibre1">798     }</p>
<p class="calibre1">799</p>
<p class="calibre1">800     /**</p>
<p class="calibre1">801      * Factory method that returns an instance of some concrete subclass of 802      * {@link SerialDate}.</p>
<p class="calibre1">803      *</p>
<p class="calibre1">804      * @param serial  the serial number for the day (1 January 1900 = 2).</p>
<p class="calibre1">805      *</p>
<p class="calibre1">806      * @return a instance of SerialDate.</p>
<p class="calibre1">807      */</p>
<p class="calibre1">808     public static SerialDate createInstance(final int serial) {</p>
<p class="calibre1">809         return new SpreadsheetDate(serial);</p>
<p class="calibre1">810     }</p>
<p class="calibre1">811</p>
<p class="calibre1">812     /**</p>
<p class="calibre1">813      * Factory method that returns an instance of a subclass of SerialDate.</p>
<p class="calibre1">814      *</p>
<p class="calibre1">815      * @param date  A Java date object.</p>
<p class="calibre1">816      *</p>
<p class="calibre1">817      * @return a instance of SerialDate.</p>
<p class="calibre1">818      */</p>
<p class="calibre1">819     public static SerialDate createInstance(final java.util.Date date) {</p>
<p class="calibre1">820</p>
<p class="calibre1">821         final GregorianCalendar calendar = new GregorianCalendar(); 822         calendar.setTime(date);</p>
<p class="calibre1">823         return new SpreadsheetDate(calendar.get(Calendar.DATE), 824                                    calendar.get(Calendar.MONTH) + 1, 825                                    calendar.get(Calendar.YEAR)); 826</p>
<p class="calibre1">827     }</p>
<p class="calibre1">828</p>
<p class="calibre1">829     /**</p>
<p class="calibre1">830      * Returns the serial number for the date, where 1 January 1900 = 2 (this 831      * corresponds, almost, to the numbering system used in Microsoft Excel for 832      * Windows and Lotus 1-2-3).</p>
<p class="calibre1">833      *</p>
<p class="calibre1">834      * @return the serial number for the date.</p>
<p class="calibre1">835      */</p>
<p class="calibre1">836     public abstract int toSerial();</p>
<p class="calibre1">837</p>
<p class="calibre1">838     /**</p>
<p class="calibre1">839      * Returns a java.util.Date.  Since java.util.Date has more precision than 840      * SerialDate, we need to define a convention for the 'time of day'.</p>
<p class="calibre1">841      *</p>
<p class="calibre1">842      * @return this as &lt;code&gt;java.util.Date&lt;/code&gt;.</p>
<p class="calibre1">843      */</p>
<p class="calibre1">844     public abstract java.util.Date toDate();</p>
<p class="calibre1">845</p>
<p class="calibre1">846     /**</p>
<p class="calibre1"><a id="p394"></a><b class="calibre3">Appendix B: org.jfree.date.SerialDate</b></p>
<p class="calibre1">363</p>
<p class="calibre1"><b class="calibre3">Listing B-1 (continued)</b></p>
<p class="calibre1"><b class="calibre3">SerialDate.Java</b></p>
<p class="calibre1">847      * Returns a description of the date.</p>
<p class="calibre1">848      *</p>
<p class="calibre1">849      * @return a description of the date.</p>
<p class="calibre1">850      */</p>
<p class="calibre1">851     public String getDescription() {</p>
<p class="calibre1">852         return this.description;</p>
<p class="calibre1">853     }</p>
<p class="calibre1">854</p>
<p class="calibre1">855     /**</p>
<p class="calibre1">856      * Sets the description for the date.</p>
<p class="calibre1">857      *</p>
<p class="calibre1">858      * @param description  the new description for the date.</p>
<p class="calibre1">859      */</p>
<p class="calibre1">860     public void setDescription(final String description) {</p>
<p class="calibre1">861         this.description = description;</p>
<p class="calibre1">862     }</p>
<p class="calibre1">863</p>
<p class="calibre1">864     /**</p>
<p class="calibre1">865      * Converts the date to a string.</p>
<p class="calibre1">866      *</p>
<p class="calibre1">867      * @return  a string representation of the date.</p>
<p class="calibre1">868      */</p>
<p class="calibre1">869     public String toString() {</p>
<p class="calibre1">870         return getDayOfMonth() + "-" + SerialDate.monthCodeToString(getMonth()) 871                                + "-" + getYYYY(); 872     }</p>
<p class="calibre1">873</p>
<p class="calibre1">874     /**</p>
<p class="calibre1">875      * Returns the year (assume a valid range of 1900 to 9999).</p>
<p class="calibre1">876      *</p>
<p class="calibre1">877      * @return the year.</p>
<p class="calibre1">878      */</p>
<p class="calibre1">879     public abstract int getYYYY();</p>
<p class="calibre1">880</p>
<p class="calibre1">881     /**</p>
<p class="calibre1">882      * Returns the month (January = 1, February = 2, March = 3).</p>
<p class="calibre1">883      *</p>
<p class="calibre1">884      * @return the month of the year.</p>
<p class="calibre1">885      */</p>
<p class="calibre1">886     public abstract int getMonth();</p>
<p class="calibre1">887</p>
<p class="calibre1">888     /**</p>
<p class="calibre1">889      * Returns the day of the month.</p>
<p class="calibre1">890      *</p>
<p class="calibre1">891      * @return the day of the month.</p>
<p class="calibre1">892      */</p>
<p class="calibre1">893     public abstract int getDayOfMonth();</p>
<p class="calibre1">894</p>
<p class="calibre1">895     /**</p>
<p class="calibre1">896      * Returns the day of the week.</p>
<p class="calibre1">897      *</p>
<p class="calibre1">898      * @return the day of the week.</p>
<p class="calibre1">899      */</p>
<p class="calibre1">900     public abstract int getDayOfWeek();</p>
<p class="calibre1">901</p>
<p class="calibre1">902     /**</p>
<p class="calibre1">903      * Returns the difference (in days) between this date and the specified 904      * 'other' date.</p>
<p class="calibre1">905      * &lt;P&gt;</p>
<p class="calibre1">906      * The result is positive if this date is after the 'other' date and 907      * negative if it is before the 'other' date.</p>
<p class="calibre1">908      *</p>
<p class="calibre1"><a id="p395"></a>364</p>
<p class="calibre1"><b class="calibre3">Appendix B: org.jfree.date.SerialDate</b></p>
<p class="calibre1"><b class="calibre3">Listing B-1 (continued)</b></p>
<p class="calibre1"><b class="calibre3">SerialDate.Java</b></p>
<p class="calibre1">909      * @param other  the date being compared to.</p>
<p class="calibre1">910      *</p>
<p class="calibre1">911      * @return the difference between this and the other date.</p>
<p class="calibre1">912      */</p>
<p class="calibre1">913     public abstract int compare(SerialDate other);</p>
<p class="calibre1">914</p>
<p class="calibre1">915     /**</p>
<p class="calibre1">916      * Returns true if this SerialDate represents the same date as the 917      * specified SerialDate.</p>
<p class="calibre1">918      *</p>
<p class="calibre1">919      * @param other  the date being compared to.</p>
<p class="calibre1">920      *</p>
<p class="calibre1">921      * @return &lt;code&gt;true&lt;/code&gt; if this SerialDate represents the same date as 922      *         the specified SerialDate.</p>
<p class="calibre1">923      */</p>
<p class="calibre1">924     public abstract boolean isOn(SerialDate other);</p>
<p class="calibre1">925</p>
<p class="calibre1">926     /**</p>
<p class="calibre1">927      * Returns true if this SerialDate represents an earlier date compared to 928      * the specified SerialDate.</p>
<p class="calibre1">929      *</p>
<p class="calibre1">930      * @param other  The date being compared to.</p>
<p class="calibre1">931      *</p>
<p class="calibre1">932      * @return &lt;code&gt;true&lt;/code&gt; if this SerialDate represents an earlier date 933      *         compared to the specified SerialDate.</p>
<p class="calibre1">934      */</p>
<p class="calibre1">935     public abstract boolean isBefore(SerialDate other);</p>
<p class="calibre1">936</p>
<p class="calibre1">937     /**</p>
<p class="calibre1">938      * Returns true if this SerialDate represents the same date as the 939      * specified SerialDate.</p>
<p class="calibre1">940      *</p>
<p class="calibre1">941      * @param other  the date being compared to.</p>
<p class="calibre1">942      *</p>
<p class="calibre1">943      * @return &lt;code&gt;true&lt;code&gt; if this SerialDate represents the same date 944      *         as the specified SerialDate.</p>
<p class="calibre1">945      */</p>
<p class="calibre1">946     public abstract boolean isOnOrBefore(SerialDate other); 947</p>
<p class="calibre1">948     /**</p>
<p class="calibre1">949      * Returns true if this SerialDate represents the same date as the 950      * specified SerialDate.</p>
<p class="calibre1">951      *</p>
<p class="calibre1">952      * @param other  the date being compared to.</p>
<p class="calibre1">953      *</p>
<p class="calibre1">954      * @return &lt;code&gt;true&lt;/code&gt; if this SerialDate represents the same date 955      *         as the specified SerialDate.</p>
<p class="calibre1">956      */</p>
<p class="calibre1">957     public abstract boolean isAfter(SerialDate other);</p>
<p class="calibre1">958</p>
<p class="calibre1">959     /**</p>
<p class="calibre1">960      * Returns true if this SerialDate represents the same date as the 961      * specified SerialDate.</p>
<p class="calibre1">962      *</p>
<p class="calibre1">963      * @param other  the date being compared to.</p>
<p class="calibre1">964      *</p>
<p class="calibre1">965      * @return &lt;code&gt;true&lt;/code&gt; if this SerialDate represents the same date 966      *         as the specified SerialDate.</p>
<p class="calibre1">967      */</p>
<p class="calibre1">968     public abstract boolean isOnOrAfter(SerialDate other); 969</p>
<p class="calibre1">970     /**</p>
<p class="calibre1">971      * Returns &lt;code&gt;true&lt;/code&gt; if this {@link SerialDate} is within the</p>
<p class="calibre1"><a id="p396"></a><b class="calibre3">Appendix B: org.jfree.date.SerialDate</b></p>
<p class="calibre1">365</p>
<p class="calibre1"><b class="calibre3">Listing B-1 (continued)</b></p>
<p class="calibre1"><b class="calibre3">SerialDate.Java</b></p>
<p class="calibre1">972      * specified range (INCLUSIVE).  The date order of d1 and d2 is not 973      * important.</p>
<p class="calibre1">974      *</p>
<p class="calibre1">975      * @param d1  a boundary date for the range.</p>
<p class="calibre1">976      * @param d2  the other boundary date for the range.</p>
<p class="calibre1">977      *</p>
<p class="calibre1">978      * @return A boolean.</p>
<p class="calibre1">979      */</p>
<p class="calibre1">980     public abstract boolean isInRange(SerialDate d1, SerialDate d2); 981</p>
<p class="calibre1">982     /**</p>
<p class="calibre1">983      * Returns &lt;code&gt;true&lt;/code&gt; if this {@link SerialDate} is within the 984      * specified range (caller specifies whether or not the end-points are 985      * included).  The date order of d1 and d2 is not important.</p>
<p class="calibre1">986      *</p>
<p class="calibre1">987      * @param d1  a boundary date for the range.</p>
<p class="calibre1">988      * @param d2  the other boundary date for the range.</p>
<p class="calibre1">989      * @param include  a code that controls whether or not the start and end 990      *                 dates are included in the range.</p>
<p class="calibre1">991      *</p>
<p class="calibre1">992      * @return A boolean.</p>
<p class="calibre1">993      */</p>
<p class="calibre1">994     public abstract boolean isInRange(SerialDate d1, SerialDate d2, 995                                       int include);</p>
<p class="calibre1">996</p>
<p class="calibre1">997     /**</p>
<p class="calibre1">998      * Returns the latest date that falls on the specified day-of-the-week and 999      * is BEFORE this date.</p>
<p class="calibre1">1000      *</p>
<p class="calibre1">1001      * @param targetDOW  a code for the target day-of-the-week.</p>
<p class="calibre1">1002      *</p>
<p class="calibre1">1003      * @return the latest date that falls on the specified day-of-the-week and 1004      *         is BEFORE this date.</p>
<p class="calibre1">1005      */</p>
<p class="calibre1">1006     public SerialDate getPreviousDayOfWeek(final int targetDOW) {</p>
<p class="calibre1">1007         return getPreviousDayOfWeek(targetDOW, this);</p>
<p class="calibre1">1008     }</p>
<p class="calibre1">1009</p>
<p class="calibre1">1010     /**</p>
<p class="calibre1">1011      * Returns the earliest date that falls on the specified day-of-the-week 1012      * and is AFTER this date.</p>
<p class="calibre1">1013      *</p>
<p class="calibre1">1014      * @param targetDOW  a code for the target day-of-the-week.</p>
<p class="calibre1">1015      *</p>
<p class="calibre1">1016      * @return the earliest date that falls on the specified day-of-the-week 1017      *         and is AFTER this date.</p>
<p class="calibre1">1018      */</p>
<p class="calibre1">1019     public SerialDate getFollowingDayOfWeek(final int targetDOW) {</p>
<p class="calibre1">1020         return getFollowingDayOfWeek(targetDOW, this);</p>
<p class="calibre1">1021     }</p>
<p class="calibre1">1022</p>
<p class="calibre1">1023     /**</p>
<p class="calibre1">1024      * Returns the nearest date that falls on the specified day-of-the-week.</p>
<p class="calibre1">1025      *</p>
<p class="calibre1">1026      * @param targetDOW  a code for the target day-of-the-week.</p>
<p class="calibre1">1027      *</p>
<p class="calibre1">1028      * @return the nearest date that falls on the specified day-of-the-week.</p>
<p class="calibre1">1029      */</p>
<p class="calibre1">1030     public SerialDate getNearestDayOfWeek(final int targetDOW) {</p>
<p class="calibre1">1031         return getNearestDayOfWeek(targetDOW, this);</p>
<p class="calibre1">1032     }</p>
<p class="calibre1">1033</p>
<p class="calibre1">1034 }</p>
<p class="calibre1"><a id="p397"></a>366</p>
<p class="calibre1"><b class="calibre3">Appendix B: org.jfree.date.SerialDate</b></p>
<p class="calibre1"><b class="calibre3">Listing B-2 </b></p>
<p class="calibre1"><b class="calibre3">SerialDateTest.java</b></p>
<p class="calibre1">1 /* ========================================================================</p>
<p class="calibre1">2  * JCommon : a free general purpose class library for the Java(tm) platform 3  * ========================================================================</p>
<p class="calibre1">4  *</p>
<p class="calibre1">5  * (C) Copyright 2000-2005, by Object Refinery Limited and Contributors.</p>
<p class="calibre1">6  *</p>
<p class="calibre1">7  * Project Info:  http://www.jfree.org/jcommon/index.html</p>
<p class="calibre1">8  *</p>
<p class="calibre1">9  * This library is free software; you can redistribute it and/or modify it 10  * under the terms of the GNU Lesser General Public License as published by 11  * the Free Software Foundation; either version 2.1 of the License, or 12  * (at your option) any later version.</p>
<p class="calibre1">13  *</p>
<p class="calibre1">14  * This library is distributed in the hope that it will be useful, but 15  * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY</p>
<p class="calibre1">16  * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public 17  * License for more details.</p>
<p class="calibre1">18  *</p>
<p class="calibre1">19  * You should have received a copy of the GNU Lesser General Public 20  * License along with this library; if not, write to the Free Software 21  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, 22  * USA.</p>
<p class="calibre1">23  *</p>
<p class="calibre1">24  * [Java is a trademark or registered trademark of Sun Microsystems, Inc.</p>
<p class="calibre1">25  * in the United States and other countries.]</p>
<p class="calibre1">26  *</p>
<p class="calibre1">27  * --------------------</p>
<p class="calibre1">28  * SerialDateTests.java</p>
<p class="calibre1">29  * --------------------</p>
<p class="calibre1">30  * (C) Copyright 2001-2005, by Object Refinery Limited.</p>
<p class="calibre1">31  *</p>
<p class="calibre1">32  * Original Author:  David Gilbert (for Object Refinery Limited); 33  * Contributor(s):   -;</p>
<p class="calibre1">34  *</p>
<p class="calibre1">35  * $Id: SerialDateTests.java,v 1.6 2005/11/16 15:58:40 taqua Exp $</p>
<p class="calibre1">36  *</p>
<p class="calibre1">37  * Changes</p>
<p class="calibre1">38  * -------</p>
<p class="calibre1">39  * 15-Nov-2001 : Version 1 (DG);</p>
<p class="calibre1">40  * 25-Jun-2002 : Removed unnecessary import (DG);</p>
<p class="calibre1">41  * 24-Oct-2002 : Fixed errors reported by Checkstyle (DG);</p>
<p class="calibre1">42  * 13-Mar-2003 : Added serialization test (DG);</p>
<p class="calibre1">43  * 05-Jan-2005 : Added test for bug report 1096282 (DG);</p>
<p class="calibre1">44  *</p>
<p class="calibre1">45  */</p>
<p class="calibre1">46</p>
<p class="calibre1">47 package org.jfree.date.junit;</p>
<p class="calibre1">48</p>
<p class="calibre1">49 import java.io.ByteArrayInputStream;</p>
<p class="calibre1">50 import java.io.ByteArrayOutputStream;</p>
<p class="calibre1">51 import java.io.ObjectInput;</p>
<p class="calibre1">52 import java.io.ObjectInputStream;</p>
<p class="calibre1">53 import java.io.ObjectOutput;</p>
<p class="calibre1">54 import java.io.ObjectOutputStream;</p>
<p class="calibre1">55</p>
<p class="calibre1">56 import junit.framework.Test;</p>
<p class="calibre1">57 import junit.framework.TestCase;</p>
<p class="calibre1">58 import junit.framework.TestSuite;</p>
<p class="calibre1">59</p>
<p class="calibre1">60 import org.jfree.date.MonthConstants;</p>
<p class="calibre1">61 import org.jfree.date.SerialDate;</p>
<p class="calibre1">62</p>
<p class="calibre1"><a id="p398"></a><b class="calibre3">Appendix B: org.jfree.date.SerialDate</b></p>
<p class="calibre1">367</p>
<p class="calibre1"><b class="calibre3">Listing B-2 (continued)</b></p>
<p class="calibre1"><b class="calibre3">SerialDateTest.java</b></p>
<p class="calibre1">63 /**</p>
<p class="calibre1">64  * Some JUnit tests for the {@link SerialDate} class.</p>
<p class="calibre1">65  */</p>
<p class="calibre1">66 public class SerialDateTests extends TestCase {</p>
<p class="calibre1">67</p>
<p class="calibre1">68     /** Date representing November 9. */</p>
<p class="calibre1">69     private SerialDate nov9Y2001;</p>
<p class="calibre1">70</p>
<p class="calibre1">71     /**</p>
<p class="calibre1">72      * Creates a new test case.</p>
<p class="calibre1">73      *</p>
<p class="calibre1">74      * @param name  the name.</p>
<p class="calibre1">75      */</p>
<p class="calibre1">76     public SerialDateTests(final String name) {</p>
<p class="calibre1">77         super(name);</p>
<p class="calibre1">78     }</p>
<p class="calibre1">79</p>
<p class="calibre1">80     /**</p>
<p class="calibre1">81      * Returns a test suite for the JUnit test runner.</p>
<p class="calibre1">82      *</p>
<p class="calibre1">83      * @return The test suite.</p>
<p class="calibre1">84      */</p>
<p class="calibre1">85     public static Test suite() {</p>
<p class="calibre1">86         return new TestSuite(SerialDateTests.class);</p>
<p class="calibre1">87     }</p>
<p class="calibre1">88</p>
<p class="calibre1">89     /**</p>
<p class="calibre1">90      * Problem set up.</p>
<p class="calibre1">91      */</p>
<p class="calibre1">92     protected void setUp() {</p>
<p class="calibre1">93         this.nov9Y2001 = SerialDate.createInstance(9, MonthConstants.NOVEMBER, 2001); 94     }</p>
<p class="calibre1">95</p>
<p class="calibre1">96     /**</p>
<p class="calibre1">97      * 9 Nov 2001 plus two months should be 9 Jan 2002.</p>
<p class="calibre1">98      */</p>
<p class="calibre1">99     public void testAddMonthsTo9Nov2001() {</p>
<p class="calibre1">100         final SerialDate jan9Y2002 = SerialDate.addMonths(2, this.nov9Y2001); 101         final SerialDate answer = SerialDate.createInstance(9, 1, 2002); 102         assertEquals(answer, jan9Y2002);</p>
<p class="calibre1">103     }</p>
<p class="calibre1">104</p>
<p class="calibre1">105     /**</p>
<p class="calibre1">106      * A test case for a reported bug, now fixed.</p>
<p class="calibre1">107      */</p>
<p class="calibre1">108     public void testAddMonthsTo5Oct2003() {</p>
<p class="calibre1">109         final SerialDate d1 = SerialDate.createInstance(5, MonthConstants.OCTOBER, 2003); 110         final SerialDate d2 = SerialDate.addMonths(2, d1); 111         assertEquals(d2, SerialDate.createInstance(5, MonthConstants.DECEMBER, 2003)); 112     }</p>
<p class="calibre1">113</p>
<p class="calibre1">114     /**</p>
<p class="calibre1">115      * A test case for a reported bug, now fixed.</p>
<p class="calibre1">116      */</p>
<p class="calibre1">117     public void testAddMonthsTo1Jan2003() {</p>
<p class="calibre1">118         final SerialDate d1 = SerialDate.createInstance(1, MonthConstants.JANUARY, 2003); 119         final SerialDate d2 = SerialDate.addMonths(0, d1); 120         assertEquals(d2, d1);</p>
<p class="calibre1">121     }</p>
<p class="calibre1">122</p>
<p class="calibre1">123     /**</p>
<p class="calibre1">124      * Monday preceding Friday 9 November 2001 should be 5 November.</p>
<p class="calibre1"><a id="p399"></a>368</p>
<p class="calibre1"><b class="calibre3">Appendix B: org.jfree.date.SerialDate</b></p>
<p class="calibre1"><b class="calibre3">Listing B-2 (continued)</b></p>
<p class="calibre1"><b class="calibre3">SerialDateTest.java</b></p>
<p class="calibre1">125      */</p>
<p class="calibre1">126     public void testMondayPrecedingFriday9Nov2001() {</p>
<p class="calibre1">127         SerialDate mondayBefore = SerialDate.getPreviousDayOfWeek(</p>
<p class="calibre1">128             SerialDate.MONDAY, this.nov9Y2001</p>
<p class="calibre1">129         );</p>
<p class="calibre1">130         assertEquals(5, mondayBefore.getDayOfMonth());</p>
<p class="calibre1">131     }</p>
<p class="calibre1">132</p>
<p class="calibre1">133     /**</p>
<p class="calibre1">134      * Monday following Friday 9 November 2001 should be 12 November.</p>
<p class="calibre1">135      */</p>
<p class="calibre1">136     public void testMondayFollowingFriday9Nov2001() {</p>
<p class="calibre1">137         SerialDate mondayAfter = SerialDate.getFollowingDayOfWeek(</p>
<p class="calibre1">138             SerialDate.MONDAY, this.nov9Y2001</p>
<p class="calibre1">139         );</p>
<p class="calibre1">140         assertEquals(12, mondayAfter.getDayOfMonth());</p>
<p class="calibre1">141     }</p>
<p class="calibre1">142</p>
<p class="calibre1">143     /**</p>
<p class="calibre1">144      * Monday nearest Friday 9 November 2001 should be 12 November.</p>
<p class="calibre1">145      */</p>
<p class="calibre1">146     public void testMondayNearestFriday9Nov2001() {</p>
<p class="calibre1">147         SerialDate mondayNearest = SerialDate.getNearestDayOfWeek(</p>
<p class="calibre1">148             SerialDate.MONDAY, this.nov9Y2001</p>
<p class="calibre1">149         );</p>
<p class="calibre1">150         assertEquals(12, mondayNearest.getDayOfMonth());</p>
<p class="calibre1">151     }</p>
<p class="calibre1">152</p>
<p class="calibre1">153     /**</p>
<p class="calibre1">154      * The Monday nearest to 22nd January 1970 falls on the 19th.</p>
<p class="calibre1">155      */</p>
<p class="calibre1">156     public void testMondayNearest22Jan1970() {</p>
<p class="calibre1">157         SerialDate jan22Y1970 = SerialDate.createInstance(22, MonthConstants.JANUARY, 1970); 158         SerialDate mondayNearest=SerialDate.getNearestDayOfWeek(SerialDate.MONDAY, jan22Y1970); 159         assertEquals(19, mondayNearest.getDayOfMonth()); 160     }</p>
<p class="calibre1">161</p>
<p class="calibre1">162     /**</p>
<p class="calibre1">163      * Problem that the conversion of days to strings returns the right result.  Actually, this 164      * result depends on the Locale so this test needs to be modified.</p>
<p class="calibre1">165      */</p>
<p class="calibre1">166     public void testWeekdayCodeToString() {</p>
<p class="calibre1">167</p>
<p class="calibre1">168         final String test = SerialDate.weekdayCodeToString(SerialDate.SATURDAY); 169         assertEquals("Saturday", test);</p>
<p class="calibre1">170</p>
<p class="calibre1">171     }</p>
<p class="calibre1">172</p>
<p class="calibre1">173     /**</p>
<p class="calibre1">174      * Test the conversion of a string to a weekday.  Note that this test will fail if the 175      * default locale doesn't use English weekday names...devise a better test!</p>
<p class="calibre1">176      */</p>
<p class="calibre1">177     public void testStringToWeekday() {</p>
<p class="calibre1">178</p>
<p class="calibre1">179         int weekday = SerialDate.stringToWeekdayCode("Wednesday"); 180         assertEquals(SerialDate.WEDNESDAY, weekday);</p>
<p class="calibre1">181</p>
<p class="calibre1">182         weekday = SerialDate.stringToWeekdayCode(" Wednesday "); 183         assertEquals(SerialDate.WEDNESDAY, weekday);</p>
<p class="calibre1">184</p>
<p class="calibre1"><a id="p400"></a><b class="calibre3">Appendix B: org.jfree.date.SerialDate</b></p>
<p class="calibre1">369</p>
<p class="calibre1"><b class="calibre3">Listing B-2 (continued)</b></p>
<p class="calibre1"><b class="calibre3">SerialDateTest.java</b></p>
<p class="calibre1">185         weekday = SerialDate.stringToWeekdayCode("Wed"); 186         assertEquals(SerialDate.WEDNESDAY, weekday);</p>
<p class="calibre1">187</p>
<p class="calibre1">188     }</p>
<p class="calibre1">189</p>
<p class="calibre1">190     /**</p>
<p class="calibre1">191      * Test the conversion of a string to a month.  Note that this test will fail if the 192      * default locale doesn't use English month names...devise a better test!</p>
<p class="calibre1">193      */</p>
<p class="calibre1">194     public void testStringToMonthCode() {</p>
<p class="calibre1">195</p>
<p class="calibre1">196         int m = SerialDate.stringToMonthCode("January"); 197         assertEquals(MonthConstants.JANUARY, m);</p>
<p class="calibre1">198</p>
<p class="calibre1">199         m = SerialDate.stringToMonthCode(" January "); 200         assertEquals(MonthConstants.JANUARY, m);</p>
<p class="calibre1">201</p>
<p class="calibre1">202         m = SerialDate.stringToMonthCode("Jan"); 203         assertEquals(MonthConstants.JANUARY, m);</p>
<p class="calibre1">204</p>
<p class="calibre1">205     }</p>
<p class="calibre1">206</p>
<p class="calibre1">207     /**</p>
<p class="calibre1">208      * Tests the conversion of a month code to a string.</p>
<p class="calibre1">209      */</p>
<p class="calibre1">210     public void testMonthCodeToStringCode() {</p>
<p class="calibre1">211</p>
<p class="calibre1">212         final String test = SerialDate.monthCodeToString(MonthConstants.DECEMBER); 213         assertEquals("December", test);</p>
<p class="calibre1">214</p>
<p class="calibre1">215     }</p>
<p class="calibre1">216</p>
<p class="calibre1">217     /**</p>
<p class="calibre1">218      * 1900 is not a leap year.</p>
<p class="calibre1">219      */</p>
<p class="calibre1">220     public void testIsNotLeapYear1900() {</p>
<p class="calibre1">221         assertTrue(!SerialDate.isLeapYear(1900));</p>
<p class="calibre1">222     }</p>
<p class="calibre1">223</p>
<p class="calibre1">224     /**</p>
<p class="calibre1">225      * 2000 is a leap year.</p>
<p class="calibre1">226      */</p>
<p class="calibre1">227     public void testIsLeapYear2000() {</p>
<p class="calibre1">228         assertTrue(SerialDate.isLeapYear(2000));</p>
<p class="calibre1">229     }</p>
<p class="calibre1">230</p>
<p class="calibre1">231     /**</p>
<p class="calibre1">232      * The number of leap years from 1900 up-to-and-including 1899 is 0.</p>
<p class="calibre1">233      */</p>
<p class="calibre1">234     public void testLeapYearCount1899() {</p>
<p class="calibre1">235         assertEquals(SerialDate.leapYearCount(1899), 0);</p>
<p class="calibre1">236     }</p>
<p class="calibre1">237</p>
<p class="calibre1">238     /**</p>
<p class="calibre1">239      * The number of leap years from 1900 up-to-and-including 1903 is 0.</p>
<p class="calibre1">240      */</p>
<p class="calibre1">241     public void testLeapYearCount1903() {</p>
<p class="calibre1">242         assertEquals(SerialDate.leapYearCount(1903), 0);</p>
<p class="calibre1">243     }</p>
<p class="calibre1">244</p>
<p class="calibre1">245     /**</p>
<p class="calibre1">246      * The number of leap years from 1900 up-to-and-including 1904 is 1.</p>
<p class="calibre1">247      */</p>
<p class="calibre1"><a id="p401"></a>370</p>
<p class="calibre1"><b class="calibre3">Appendix B: org.jfree.date.SerialDate</b></p>
<p class="calibre1"><b class="calibre3">Listing B-2 (continued)</b></p>
<p class="calibre1"><b class="calibre3">SerialDateTest.java</b></p>
<p class="calibre1">248     public void testLeapYearCount1904() {</p>
<p class="calibre1">249         assertEquals(SerialDate.leapYearCount(1904), 1);</p>
<p class="calibre1">250     }</p>
<p class="calibre1">251</p>
<p class="calibre1">252     /**</p>
<p class="calibre1">253      * The number of leap years from 1900 up-to-and-including 1999 is 24.</p>
<p class="calibre1">254      */</p>
<p class="calibre1">255     public void testLeapYearCount1999() {</p>
<p class="calibre1">256         assertEquals(SerialDate.leapYearCount(1999), 24);</p>
<p class="calibre1">257     }</p>
<p class="calibre1">258</p>
<p class="calibre1">259     /**</p>
<p class="calibre1">260      * The number of leap years from 1900 up-to-and-including 2000 is 25.</p>
<p class="calibre1">261      */</p>
<p class="calibre1">262     public void testLeapYearCount2000() {</p>
<p class="calibre1">263         assertEquals(SerialDate.leapYearCount(2000), 25);</p>
<p class="calibre1">264     }</p>
<p class="calibre1">265</p>
<p class="calibre1">266     /**</p>
<p class="calibre1">267      * Serialize an instance, restore it, and check for equality.</p>
<p class="calibre1">268      */</p>
<p class="calibre1">269     public void testSerialization() {</p>
<p class="calibre1">270</p>
<p class="calibre1">271         SerialDate d1 = SerialDate.createInstance(15, 4, 2000); 272         SerialDate d2 = null;</p>
<p class="calibre1">273</p>
<p class="calibre1">274         try {</p>
<p class="calibre1">275             ByteArrayOutputStream buffer = new ByteArrayOutputStream(); 276             ObjectOutput out = new ObjectOutputStream(buffer); 277             out.writeObject(d1);</p>
<p class="calibre1">278             out.close();</p>
<p class="calibre1">279</p>
<p class="calibre1">280             ObjectInput in = new ObjectInputStream(</p>
<p class="calibre1">new ByteArrayInputStream(buffer.toByteArray()));</p>
<p class="calibre1">281             d2 = (SerialDate) in.readObject();</p>
<p class="calibre1">282             in.close();</p>
<p class="calibre1">283         }</p>
<p class="calibre1">284         catch (Exception e) {</p>
<p class="calibre1">285             System.out.println(e.toString());</p>
<p class="calibre1">286         }</p>
<p class="calibre1">287         assertEquals(d1, d2);</p>
<p class="calibre1">288</p>
<p class="calibre1">289     }</p>
<p class="calibre1">290</p>
<p class="calibre1">291     /**</p>
<p class="calibre1">292      * A test for bug report 1096282 (now fixed).</p>
<p class="calibre1">293      */</p>
<p class="calibre1">294     public void test1096282() {</p>
<p class="calibre1">295         SerialDate d = SerialDate.createInstance(29, 2, 2004); 296         d = SerialDate.addYears(1, d);</p>
<p class="calibre1">297         SerialDate expected = SerialDate.createInstance(28, 2, 2005); 298         assertTrue(d.isOn(expected));</p>
<p class="calibre1">299     }</p>
<p class="calibre1">300</p>
<p class="calibre1">301     /**</p>
<p class="calibre1">302      * Miscellaneous tests for the addMonths() method.</p>
<p class="calibre1">303      */</p>
<p class="calibre1">304     public void testAddMonths() {</p>
<p class="calibre1">305         SerialDate d1 = SerialDate.createInstance(31, 5, 2004); 306</p>
<p class="calibre1"><a id="p402"></a><b class="calibre3">Appendix B: org.jfree.date.SerialDate</b></p>
<p class="calibre1">371</p>
<p class="calibre1"><b class="calibre3">Listing B-2 (continued)</b></p>
<p class="calibre1"><b class="calibre3">SerialDateTest.java</b></p>
<p class="calibre1">307         SerialDate d2 = SerialDate.addMonths(1, d1);</p>
<p class="calibre1">308         assertEquals(30, d2.getDayOfMonth());</p>
<p class="calibre1">309         assertEquals(6, d2.getMonth());</p>
<p class="calibre1">310         assertEquals(2004, d2.getYYYY());</p>
<p class="calibre1">311</p>
<p class="calibre1">312         SerialDate d3 = SerialDate.addMonths(2, d1);</p>
<p class="calibre1">313         assertEquals(31, d3.getDayOfMonth());</p>
<p class="calibre1">314         assertEquals(7, d3.getMonth());</p>
<p class="calibre1">315         assertEquals(2004, d3.getYYYY());</p>
<p class="calibre1">316</p>
<p class="calibre1">317         SerialDate d4 = SerialDate.addMonths(1, SerialDate.addMonths(1, d1)); 318         assertEquals(30, d4.getDayOfMonth());</p>
<p class="calibre1">319         assertEquals(7, d4.getMonth());</p>
<p class="calibre1">320         assertEquals(2004, d4.getYYYY());</p>
<p class="calibre1">321     }</p>
<p class="calibre1">322 }</p>
<p class="calibre1"><a id="p403"></a>372</p>
<p class="calibre1"><b class="calibre3">Appendix B: org.jfree.date.SerialDate</b></p>
<p class="calibre1"><b class="calibre3">Listing B-3 </b></p>
<p class="calibre1"><b class="calibre3">MonthConstants.java</b></p>
<p class="calibre1">1 /* ========================================================================</p>
<p class="calibre1">2  * JCommon : a free general purpose class library for the Java(tm) platform 3  * ========================================================================</p>
<p class="calibre1">4  *</p>
<p class="calibre1">5  * (C) Copyright 2000-2005, by Object Refinery Limited and Contributors.</p>
<p class="calibre1">6  *</p>
<p class="calibre1">7  * Project Info:  http://www.jfree.org/jcommon/index.html</p>
<p class="calibre1">8  *</p>
<p class="calibre1">9  * This library is free software; you can redistribute it and/or modify it 10  * under the terms of the GNU Lesser General Public License as published by 11  * the Free Software Foundation; either version 2.1 of the License, or 12  * (at your option) any later version.</p>
<p class="calibre1">13  *</p>
<p class="calibre1">14  * This library is distributed in the hope that it will be useful, but 15  * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY</p>
<p class="calibre1">16  * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public 17  * License for more details.</p>
<p class="calibre1">18  *</p>
<p class="calibre1">19  * You should have received a copy of the GNU Lesser General Public 20  * License along with this library; if not, write to the Free Software 21  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, 22  * USA.</p>
<p class="calibre1">23  *</p>
<p class="calibre1">24  * [Java is a trademark or registered trademark of Sun Microsystems, Inc.</p>
<p class="calibre1">25  * in the United States and other countries.]</p>
<p class="calibre1">26  *</p>
<p class="calibre1">27  * -------------------</p>
<p class="calibre1">28  * MonthConstants.java</p>
<p class="calibre1">29  * -------------------</p>
<p class="calibre1">30  * (C) Copyright 2002, 2003, by Object Refinery Limited.</p>
<p class="calibre1">31  *</p>
<p class="calibre1">32  * Original Author:  David Gilbert (for Object Refinery Limited); 33  * Contributor(s):   -;</p>
<p class="calibre1">34  *</p>
<p class="calibre1">35  * $Id: MonthConstants.java,v 1.4 2005/11/16 15:58:40 taqua Exp $</p>
<p class="calibre1">36  *</p>
<p class="calibre1">37  * Changes</p>
<p class="calibre1">38  * -------</p>
<p class="calibre1">39  * 29-May-2002 : Version 1 (code moved from SerialDate class) (DG); 40  *</p>
<p class="calibre1">41  */</p>
<p class="calibre1">42</p>
<p class="calibre1">43 package org.jfree.date;</p>
<p class="calibre1">44</p>
<p class="calibre1">45 /**</p>
<p class="calibre1">46  * Useful constants for months.  Note that these are NOT equivalent to the 47  * constants defined by java.util.Calendar (where JANUARY=0 and DECEMBER=11).</p>
<p class="calibre1">48  * &lt;P&gt;</p>
<p class="calibre1">49  * Used by the SerialDate and RegularTimePeriod classes.</p>
<p class="calibre1">50  *</p>
<p class="calibre1">51  * @author David Gilbert</p>
<p class="calibre1">52  */</p>
<p class="calibre1">53 public interface MonthConstants {</p>
<p class="calibre1">54</p>
<p class="calibre1">55     /** Constant for January. */</p>
<p class="calibre1">56     public static final int JANUARY = 1;</p>
<p class="calibre1">57</p>
<p class="calibre1">58     /** Constant for February. */</p>
<p class="calibre1">59     public static final int FEBRUARY = 2;</p>
<p class="calibre1">60</p>
<p class="calibre1"><a id="p404"></a><b class="calibre3">Appendix B: org.jfree.date.SerialDate</b></p>
<p class="calibre1">373</p>
<p class="calibre1"><b class="calibre3">Listing B-3 (continued)</b></p>
<p class="calibre1"><b class="calibre3">MonthConstants.java</b></p>
<p class="calibre1">61     /** Constant for March. */</p>
<p class="calibre1">62     public static final int MARCH = 3;</p>
<p class="calibre1">63</p>
<p class="calibre1">64     /** Constant for April. */</p>
<p class="calibre1">65     public static final int APRIL = 4;</p>
<p class="calibre1">66</p>
<p class="calibre1">67     /** Constant for May. */</p>
<p class="calibre1">68     public static final int MAY = 5;</p>
<p class="calibre1">69</p>
<p class="calibre1">70     /** Constant for June. */</p>
<p class="calibre1">71     public static final int JUNE = 6;</p>
<p class="calibre1">72</p>
<p class="calibre1">73     /** Constant for July. */</p>
<p class="calibre1">74     public static final int JULY = 7;</p>
<p class="calibre1">75</p>
<p class="calibre1">76     /** Constant for August. */</p>
<p class="calibre1">77     public static final int AUGUST = 8;</p>
<p class="calibre1">78</p>
<p class="calibre1">79     /** Constant for September. */</p>
<p class="calibre1">80     public static final int SEPTEMBER = 9;</p>
<p class="calibre1">81</p>
<p class="calibre1">82     /** Constant for October. */</p>
<p class="calibre1">83     public static final int OCTOBER = 10;</p>
<p class="calibre1">84</p>
<p class="calibre1">85     /** Constant for November. */</p>
<p class="calibre1">86     public static final int NOVEMBER = 11;</p>
<p class="calibre1">87</p>
<p class="calibre1">88     /** Constant for December. */</p>
<p class="calibre1">89     public static final int DECEMBER = 12;</p>
<p class="calibre1">90</p>
<p class="calibre1">91 }</p>
<p class="calibre1"><a id="p405"></a>374</p>
<p class="calibre1"><b class="calibre3">Appendix B: org.jfree.date.SerialDate</b></p>
<p class="calibre1"><b class="calibre3">Listing B-4 </b></p>
<p class="calibre1"><b class="calibre3">BobsSerialDateTest.java</b></p>
<p class="calibre1">1 package org.jfree.date.junit;</p>
<p class="calibre1">2</p>
<p class="calibre1">3 import junit.framework.TestCase;</p>
<p class="calibre1">4 import org.jfree.date.*;</p>
<p class="calibre1">5 import static org.jfree.date.SerialDate.*;</p>
<p class="calibre1">6</p>
<p class="calibre1">7 import java.util.*;</p>
<p class="calibre1">8</p>
<p class="calibre1">9 public class BobsSerialDateTest extends TestCase {</p>
<p class="calibre1">10</p>
<p class="calibre1">11   public void testIsValidWeekdayCode() throws Exception {</p>
<p class="calibre1">12     for (int day = 1; day &lt;= 7; day++)</p>
<p class="calibre1">13       assertTrue(isValidWeekdayCode(day));</p>
<p class="calibre1">14     assertFalse(isValidWeekdayCode(0));</p>
<p class="calibre1">15     assertFalse(isValidWeekdayCode(8));</p>
<p class="calibre1">16   }</p>
<p class="calibre1">17</p>
<p class="calibre1">18   public void testStringToWeekdayCode() throws Exception {</p>
<p class="calibre1">19</p>
<p class="calibre1">20     assertEquals(-1, stringToWeekdayCode("Hello")); 21     assertEquals(MONDAY, stringToWeekdayCode("Monday")); 22     assertEquals(MONDAY, stringToWeekdayCode("Mon")); 23 //todo    assertEquals(MONDAY,stringToWeekdayCode("monday")); 24 //    assertEquals(MONDAY,stringToWeekdayCode("MONDAY")); 25 //    assertEquals(MONDAY, stringToWeekdayCode("mon")); 26</p>
<p class="calibre1">27     assertEquals(TUESDAY, stringToWeekdayCode("Tuesday")); 28     assertEquals(TUESDAY, stringToWeekdayCode("Tue")); 29 //    assertEquals(TUESDAY,stringToWeekdayCode("tuesday")); 30 //    assertEquals(TUESDAY,stringToWeekdayCode("TUESDAY")); 31 //    assertEquals(TUESDAY, stringToWeekdayCode("tue")); 32 //    assertEquals(TUESDAY, stringToWeekdayCode("tues")); 33</p>
<p class="calibre1">34     assertEquals(WEDNESDAY, stringToWeekdayCode("Wednesday")); 35     assertEquals(WEDNESDAY, stringToWeekdayCode("Wed")); 36 //    assertEquals(WEDNESDAY,stringToWeekdayCode("wednesday")); 37 //    assertEquals(WEDNESDAY,stringToWeekdayCode("WEDNESDAY")); 38 //    assertEquals(WEDNESDAY, stringToWeekdayCode("wed")); 39</p>
<p class="calibre1">40     assertEquals(THURSDAY, stringToWeekdayCode("Thursday")); 41     assertEquals(THURSDAY, stringToWeekdayCode("Thu")); 42 //    assertEquals(THURSDAY,stringToWeekdayCode("thursday")); 43 //    assertEquals(THURSDAY,stringToWeekdayCode("THURSDAY")); 44 //    assertEquals(THURSDAY, stringToWeekdayCode("thu")); 45 //    assertEquals(THURSDAY, stringToWeekdayCode("thurs")); 46</p>
<p class="calibre1">47     assertEquals(FRIDAY, stringToWeekdayCode("Friday")); 48     assertEquals(FRIDAY, stringToWeekdayCode("Fri")); 49 //    assertEquals(FRIDAY,stringToWeekdayCode("friday")); 50 //    assertEquals(FRIDAY,stringToWeekdayCode("FRIDAY")); 51 //    assertEquals(FRIDAY, stringToWeekdayCode("fri")); 52</p>
<p class="calibre1">53     assertEquals(SATURDAY, stringToWeekdayCode("Saturday")); 54     assertEquals(SATURDAY, stringToWeekdayCode("Sat")); 55 //    assertEquals(SATURDAY,stringToWeekdayCode("saturday")); 56 //    assertEquals(SATURDAY,stringToWeekdayCode("SATURDAY")); 57 //    assertEquals(SATURDAY, stringToWeekdayCode("sat")); 58</p>
<p class="calibre1">59     assertEquals(SUNDAY, stringToWeekdayCode("Sunday")); 60     assertEquals(SUNDAY, stringToWeekdayCode("Sun")); 61 //    assertEquals(SUNDAY,stringToWeekdayCode("sunday")); 62 //    assertEquals(SUNDAY,stringToWeekdayCode("SUNDAY")); 63 //    assertEquals(SUNDAY, stringToWeekdayCode("sun")); 64   }</p>
<p class="calibre1">65</p>
<p class="calibre1"><a id="p406"></a><b class="calibre3">Appendix B: org.jfree.date.SerialDate</b></p>
<p class="calibre1">375</p>
<p class="calibre1"><b class="calibre3">Listing B-4 (continued)</b></p>
<p class="calibre1"><b class="calibre3">BobsSerialDateTest.java</b></p>
<p class="calibre1">66   public void testWeekdayCodeToString() throws Exception {</p>
<p class="calibre1">67     assertEquals("Sunday", weekdayCodeToString(SUNDAY)); 68     assertEquals("Monday", weekdayCodeToString(MONDAY)); 69     assertEquals("Tuesday", weekdayCodeToString(TUESDAY)); 70     assertEquals("Wednesday", weekdayCodeToString(WEDNESDAY)); 71     assertEquals("Thursday", weekdayCodeToString(THURSDAY)); 72     assertEquals("Friday", weekdayCodeToString(FRIDAY)); 73     assertEquals("Saturday", weekdayCodeToString(SATURDAY)); 74   }</p>
<p class="calibre1">75</p>
<p class="calibre1">76   public void testIsValidMonthCode() throws Exception {</p>
<p class="calibre1">77     for (int i = 1; i &lt;= 12; i++)</p>
<p class="calibre1">78       assertTrue(isValidMonthCode(i));</p>
<p class="calibre1">79     assertFalse(isValidMonthCode(0));</p>
<p class="calibre1">80     assertFalse(isValidMonthCode(13));</p>
<p class="calibre1">81   }</p>
<p class="calibre1">82</p>
<p class="calibre1">83   public void testMonthToQuarter() throws Exception {</p>
<p class="calibre1">84     assertEquals(1, monthCodeToQuarter(JANUARY));</p>
<p class="calibre1">85     assertEquals(1, monthCodeToQuarter(FEBRUARY));</p>
<p class="calibre1">86     assertEquals(1, monthCodeToQuarter(MARCH));</p>
<p class="calibre1">87     assertEquals(2, monthCodeToQuarter(APRIL));</p>
<p class="calibre1">88     assertEquals(2, monthCodeToQuarter(MAY));</p>
<p class="calibre1">89     assertEquals(2, monthCodeToQuarter(JUNE));</p>
<p class="calibre1">90     assertEquals(3, monthCodeToQuarter(JULY));</p>
<p class="calibre1">91     assertEquals(3, monthCodeToQuarter(AUGUST));</p>
<p class="calibre1">92     assertEquals(3, monthCodeToQuarter(SEPTEMBER));</p>
<p class="calibre1">93     assertEquals(4, monthCodeToQuarter(OCTOBER));</p>
<p class="calibre1">94     assertEquals(4, monthCodeToQuarter(NOVEMBER));</p>
<p class="calibre1">95     assertEquals(4, monthCodeToQuarter(DECEMBER));</p>
<p class="calibre1">96</p>
<p class="calibre1">97     try {</p>
<p class="calibre1">98       monthCodeToQuarter(-1);</p>
<p class="calibre1">99       fail("Invalid Month Code should throw exception"); 100     } catch (IllegalArgumentException e) {</p>
<p class="calibre1">101     }</p>
<p class="calibre1">102   }</p>
<p class="calibre1">103</p>
<p class="calibre1">104   public void testMonthCodeToString() throws Exception {</p>
<p class="calibre1">105     assertEquals("January", monthCodeToString(JANUARY)); 106     assertEquals("February", monthCodeToString(FEBRUARY)); 107     assertEquals("March", monthCodeToString(MARCH)); 108     assertEquals("April", monthCodeToString(APRIL)); 109     assertEquals("May", monthCodeToString(MAY)); 110     assertEquals("June", monthCodeToString(JUNE)); 111     assertEquals("July", monthCodeToString(JULY)); 112     assertEquals("August", monthCodeToString(AUGUST)); 113     assertEquals("September", monthCodeToString(SEPTEMBER)); 114     assertEquals("October", monthCodeToString(OCTOBER)); 115     assertEquals("November", monthCodeToString(NOVEMBER)); 116     assertEquals("December", monthCodeToString(DECEMBER)); 117</p>
<p class="calibre1">118     assertEquals("Jan", monthCodeToString(JANUARY, true)); 119     assertEquals("Feb", monthCodeToString(FEBRUARY, true)); 120     assertEquals("Mar", monthCodeToString(MARCH, true)); 121     assertEquals("Apr", monthCodeToString(APRIL, true)); 122     assertEquals("May", monthCodeToString(MAY, true)); 123     assertEquals("Jun", monthCodeToString(JUNE, true)); 124     assertEquals("Jul", monthCodeToString(JULY, true)); 125     assertEquals("Aug", monthCodeToString(AUGUST, true)); 126     assertEquals("Sep", monthCodeToString(SEPTEMBER, true)); 127     assertEquals("Oct", monthCodeToString(OCTOBER, true)); <a id="p407"></a>376</p>
<p class="calibre1"><b class="calibre3">Appendix B: org.jfree.date.SerialDate</b></p>
<p class="calibre1"><b class="calibre3">Listing B-4 (continued)</b></p>
<p class="calibre1"><b class="calibre3">BobsSerialDateTest.java</b></p>
<p class="calibre1">128     assertEquals("Nov", monthCodeToString(NOVEMBER, true)); 129     assertEquals("Dec", monthCodeToString(DECEMBER, true)); 130</p>
<p class="calibre1">131     try {</p>
<p class="calibre1">132       monthCodeToString(-1);</p>
<p class="calibre1">133       fail("Invalid month code should throw exception"); 134     } catch (IllegalArgumentException e) {</p>
<p class="calibre1">135     }</p>
<p class="calibre1">136</p>
<p class="calibre1">137   }</p>
<p class="calibre1">138</p>
<p class="calibre1">139   public void testStringToMonthCode() throws Exception {</p>
<p class="calibre1">140     assertEquals(JANUARY,stringToMonthCode("1")); 141     assertEquals(FEBRUARY,stringToMonthCode("2")); 142     assertEquals(MARCH,stringToMonthCode("3"));</p>
<p class="calibre1">143     assertEquals(APRIL,stringToMonthCode("4"));</p>
<p class="calibre1">144     assertEquals(MAY,stringToMonthCode("5"));</p>
<p class="calibre1">145     assertEquals(JUNE,stringToMonthCode("6"));</p>
<p class="calibre1">146     assertEquals(JULY,stringToMonthCode("7"));</p>
<p class="calibre1">147     assertEquals(AUGUST,stringToMonthCode("8")); 148     assertEquals(SEPTEMBER,stringToMonthCode("9")); 149     assertEquals(OCTOBER,stringToMonthCode("10")); 150     assertEquals(NOVEMBER, stringToMonthCode("11")); 151     assertEquals(DECEMBER,stringToMonthCode("12")); 152</p>
<p class="calibre1">153 //todo    assertEquals(-1, stringToMonthCode("0")); 154 //    assertEquals(-1, stringToMonthCode("13")); 155</p>
<p class="calibre1">156     assertEquals(-1,stringToMonthCode("Hello")); 157</p>
<p class="calibre1">158     for (int m = 1; m &lt;= 12; m++) {</p>
<p class="calibre1">159       assertEquals(m, stringToMonthCode(monthCodeToString(m, false))); 160       assertEquals(m, stringToMonthCode(monthCodeToString(m, true))); 161     }</p>
<p class="calibre1">162</p>
<p class="calibre1">163 //    assertEquals(1,stringToMonthCode("jan"));</p>
<p class="calibre1">164 //    assertEquals(2,stringToMonthCode("feb"));</p>
<p class="calibre1">165 //    assertEquals(3,stringToMonthCode("mar"));</p>
<p class="calibre1">166 //    assertEquals(4,stringToMonthCode("apr"));</p>
<p class="calibre1">167 //    assertEquals(5,stringToMonthCode("may"));</p>
<p class="calibre1">168 //    assertEquals(6,stringToMonthCode("jun"));</p>
<p class="calibre1">169 //    assertEquals(7,stringToMonthCode("jul"));</p>
<p class="calibre1">170 //    assertEquals(8,stringToMonthCode("aug"));</p>
<p class="calibre1">171 //    assertEquals(9,stringToMonthCode("sep"));</p>
<p class="calibre1">172 //    assertEquals(10,stringToMonthCode("oct")); 173 //    assertEquals(11,stringToMonthCode("nov")); 174 //    assertEquals(12,stringToMonthCode("dec")); 175</p>
<p class="calibre1">176 //    assertEquals(1,stringToMonthCode("JAN"));</p>
<p class="calibre1">177 //    assertEquals(2,stringToMonthCode("FEB"));</p>
<p class="calibre1">178 //    assertEquals(3,stringToMonthCode("MAR"));</p>
<p class="calibre1">179 //    assertEquals(4,stringToMonthCode("APR"));</p>
<p class="calibre1">180 //    assertEquals(5,stringToMonthCode("MAY"));</p>
<p class="calibre1">181 //    assertEquals(6,stringToMonthCode("JUN"));</p>
<p class="calibre1">182 //    assertEquals(7,stringToMonthCode("JUL"));</p>
<p class="calibre1">183 //    assertEquals(8,stringToMonthCode("AUG"));</p>
<p class="calibre1">184 //    assertEquals(9,stringToMonthCode("SEP"));</p>
<p class="calibre1">185 //    assertEquals(10,stringToMonthCode("OCT")); 186 //    assertEquals(11,stringToMonthCode("NOV")); 187 //    assertEquals(12,stringToMonthCode("DEC")); 188</p>
<p class="calibre1">189 //    assertEquals(1,stringToMonthCode("january")); 190 //    assertEquals(2,stringToMonthCode("february"));</p>
<p class="calibre1"><a id="p408"></a><b class="calibre3">Appendix B: org.jfree.date.SerialDate</b></p>
<p class="calibre1">377</p>
<p class="calibre1"><b class="calibre3">Listing B-4 (continued)</b></p>
<p class="calibre1"><b class="calibre3">BobsSerialDateTest.java</b></p>
<p class="calibre1">191 //    assertEquals(3,stringToMonthCode("march")); 192 //    assertEquals(4,stringToMonthCode("april")); 193 //    assertEquals(5,stringToMonthCode("may"));</p>
<p class="calibre1">194 //    assertEquals(6,stringToMonthCode("june")); 195 //    assertEquals(7,stringToMonthCode("july")); 196 //    assertEquals(8,stringToMonthCode("august")); 197 //    assertEquals(9,stringToMonthCode("september")); 198 //    assertEquals(10,stringToMonthCode("october")); 199 //    assertEquals(11,stringToMonthCode("november")); 200 //    assertEquals(12,stringToMonthCode("december")); 201</p>
<p class="calibre1">202 //    assertEquals(1,stringToMonthCode("JANUARY")); 203 //    assertEquals(2,stringToMonthCode("FEBRUARY")); 204 //    assertEquals(3,stringToMonthCode("MAR"));</p>
<p class="calibre1">205 //    assertEquals(4,stringToMonthCode("APRIL")); 206 //    assertEquals(5,stringToMonthCode("MAY"));</p>
<p class="calibre1">207 //    assertEquals(6,stringToMonthCode("JUNE")); 208 //    assertEquals(7,stringToMonthCode("JULY")); 209 //    assertEquals(8,stringToMonthCode("AUGUST")); 210 //    assertEquals(9,stringToMonthCode("SEPTEMBER")); 211 //    assertEquals(10,stringToMonthCode("OCTOBER")); 212 //    assertEquals(11,stringToMonthCode("NOVEMBER")); 213 //    assertEquals(12,stringToMonthCode("DECEMBER")); 214   }</p>
<p class="calibre1">215</p>
<p class="calibre1">216   public void testIsValidWeekInMonthCode() throws Exception {</p>
<p class="calibre1">217     for (int w = 0; w &lt;= 4; w++) {</p>
<p class="calibre1">218       assertTrue(isValidWeekInMonthCode(w));</p>
<p class="calibre1">219     }</p>
<p class="calibre1">220     assertFalse(isValidWeekInMonthCode(5));</p>
<p class="calibre1">221   }</p>
<p class="calibre1">222</p>
<p class="calibre1">223   public void testIsLeapYear() throws Exception {</p>
<p class="calibre1">224     assertFalse(isLeapYear(1900));</p>
<p class="calibre1">225     assertFalse(isLeapYear(1901));</p>
<p class="calibre1">226     assertFalse(isLeapYear(1902));</p>
<p class="calibre1">227     assertFalse(isLeapYear(1903));</p>
<p class="calibre1">228     assertTrue(isLeapYear(1904));</p>
<p class="calibre1">229     assertTrue(isLeapYear(1908));</p>
<p class="calibre1">230     assertFalse(isLeapYear(1955));</p>
<p class="calibre1">231     assertTrue(isLeapYear(1964));</p>
<p class="calibre1">232     assertTrue(isLeapYear(1980));</p>
<p class="calibre1">233     assertTrue(isLeapYear(2000));</p>
<p class="calibre1">234     assertFalse(isLeapYear(2001));</p>
<p class="calibre1">235     assertFalse(isLeapYear(2100));</p>
<p class="calibre1">236   }</p>
<p class="calibre1">237</p>
<p class="calibre1">238   public void testLeapYearCount() throws Exception {</p>
<p class="calibre1">239     assertEquals(0, leapYearCount(1900));</p>
<p class="calibre1">240     assertEquals(0, leapYearCount(1901));</p>
<p class="calibre1">241     assertEquals(0, leapYearCount(1902));</p>
<p class="calibre1">242     assertEquals(0, leapYearCount(1903));</p>
<p class="calibre1">243     assertEquals(1, leapYearCount(1904));</p>
<p class="calibre1">244     assertEquals(1, leapYearCount(1905));</p>
<p class="calibre1">245     assertEquals(1, leapYearCount(1906));</p>
<p class="calibre1">246     assertEquals(1, leapYearCount(1907));</p>
<p class="calibre1">247     assertEquals(2, leapYearCount(1908));</p>
<p class="calibre1">248     assertEquals(24, leapYearCount(1999));</p>
<p class="calibre1">249     assertEquals(25, leapYearCount(2001));</p>
<p class="calibre1">250     assertEquals(49, leapYearCount(2101));</p>
<p class="calibre1">251     assertEquals(73, leapYearCount(2201));</p>
<p class="calibre1"><a id="p409"></a>378</p>
<p class="calibre1"><b class="calibre3">Appendix B: org.jfree.date.SerialDate</b></p>
<p class="calibre1"><b class="calibre3">Listing B-4 (continued)</b></p>
<p class="calibre1"><b class="calibre3">BobsSerialDateTest.java</b></p>
<p class="calibre1">252     assertEquals(97, leapYearCount(2301));</p>
<p class="calibre1">253     assertEquals(122, leapYearCount(2401));</p>
<p class="calibre1">254   }</p>
<p class="calibre1">255</p>
<p class="calibre1">256   public void testLastDayOfMonth() throws Exception {</p>
<p class="calibre1">257     assertEquals(31, lastDayOfMonth(JANUARY, 1901));</p>
<p class="calibre1">258     assertEquals(28, lastDayOfMonth(FEBRUARY, 1901));</p>
<p class="calibre1">259     assertEquals(31, lastDayOfMonth(MARCH, 1901));</p>
<p class="calibre1">260     assertEquals(30, lastDayOfMonth(APRIL, 1901));</p>
<p class="calibre1">261     assertEquals(31, lastDayOfMonth(MAY, 1901));</p>
<p class="calibre1">262     assertEquals(30, lastDayOfMonth(JUNE, 1901));</p>
<p class="calibre1">263     assertEquals(31, lastDayOfMonth(JULY, 1901));</p>
<p class="calibre1">264     assertEquals(31, lastDayOfMonth(AUGUST, 1901));</p>
<p class="calibre1">265     assertEquals(30, lastDayOfMonth(SEPTEMBER, 1901));</p>
<p class="calibre1">266     assertEquals(31, lastDayOfMonth(OCTOBER, 1901));</p>
<p class="calibre1">267     assertEquals(30, lastDayOfMonth(NOVEMBER, 1901));</p>
<p class="calibre1">268     assertEquals(31, lastDayOfMonth(DECEMBER, 1901));</p>
<p class="calibre1">269     assertEquals(29, lastDayOfMonth(FEBRUARY, 1904));</p>
<p class="calibre1">270   }</p>
<p class="calibre1">271</p>
<p class="calibre1">272   public void testAddDays() throws Exception {</p>
<p class="calibre1">273     SerialDate newYears = d(1, JANUARY, 1900);</p>
<p class="calibre1">274     assertEquals(d(2, JANUARY, 1900), addDays(1, newYears)); 275     assertEquals(d(1, FEBRUARY, 1900), addDays(31, newYears)); 276     assertEquals(d(1, JANUARY, 1901), addDays(365, newYears)); 277     assertEquals(d(31, DECEMBER, 1904), addDays(5 * 365, newYears)); 278   }</p>
<p class="calibre1">279</p>
<p class="calibre1">280   private static SpreadsheetDate d(int day, int month, int year) {return new SpreadsheetDate(day, month, year);}</p>
<p class="calibre1">281</p>
<p class="calibre1">282   public void testAddMonths() throws Exception {</p>
<p class="calibre1">283     assertEquals(d(1, FEBRUARY, 1900), addMonths(1, d(1, JANUARY, 1900))); 284     assertEquals(d(28, FEBRUARY, 1900), addMonths(1, d(31, JANUARY, 1900))); 285     assertEquals(d(28, FEBRUARY, 1900), addMonths(1, d(30, JANUARY, 1900))); 286     assertEquals(d(28, FEBRUARY, 1900), addMonths(1, d(29, JANUARY, 1900))); 287     assertEquals(d(28, FEBRUARY, 1900), addMonths(1, d(28, JANUARY, 1900))); 288     assertEquals(d(27, FEBRUARY, 1900), addMonths(1, d(27, JANUARY, 1900))); 289</p>
<p class="calibre1">290     assertEquals(d(30, JUNE, 1900), addMonths(5, d(31, JANUARY, 1900))); 291     assertEquals(d(30, JUNE, 1901), addMonths(17, d(31, JANUARY, 1900))); 292</p>
<p class="calibre1">293     assertEquals(d(29, FEBRUARY, 1904), addMonths(49, d(31, JANUARY, 1900))); 294</p>
<p class="calibre1">295   }</p>
<p class="calibre1">296</p>
<p class="calibre1">297   public void testAddYears() throws Exception {</p>
<p class="calibre1">298     assertEquals(d(1, JANUARY, 1901), addYears(1, d(1, JANUARY, 1900))); 299     assertEquals(d(28, FEBRUARY, 1905), addYears(1, d(29, FEBRUARY, 1904))); 300     assertEquals(d(28, FEBRUARY, 1905), addYears(1, d(28, FEBRUARY, 1904))); 301     assertEquals(d(28, FEBRUARY, 1904), addYears(1, d(28, FEBRUARY, 1903))); 302   }</p>
<p class="calibre1">303</p>
<p class="calibre1">304   public void testGetPreviousDayOfWeek() throws Exception {</p>
<p class="calibre1">305     assertEquals(d(24, FEBRUARY, 2006), getPreviousDayOfWeek(FRIDAY, d(1, MARCH, 2006))); 306     assertEquals(d(22, FEBRUARY, 2006), getPreviousDayOfWeek(WEDNESDAY, d(1, MARCH, 2006))); 307     assertEquals(d(29, FEBRUARY, 2004), getPreviousDayOfWeek(SUNDAY, d(3, MARCH, 2004))); 308     assertEquals(d(29, DECEMBER, 2004), getPreviousDayOfWeek(WEDNESDAY, d(5, JANUARY, 2005))); 309</p>
<p class="calibre1">310     try {</p>
<p class="calibre1">311       getPreviousDayOfWeek(-1, d(1, JANUARY, 2006));</p>
<p class="calibre1">312       fail("Invalid day of week code should throw exception");</p>
<p class="calibre1"><a id="p410"></a><b class="calibre3">Appendix B: org.jfree.date.SerialDate</b></p>
<p class="calibre1">379</p>
<p class="calibre1"><b class="calibre3">Listing B-4 (continued)</b></p>
<p class="calibre1"><b class="calibre3">BobsSerialDateTest.java</b></p>
<p class="calibre1">313     } catch (IllegalArgumentException e) {</p>
<p class="calibre1">314     }</p>
<p class="calibre1">315   }</p>
<p class="calibre1">316</p>
<p class="calibre1">317   public void testGetFollowingDayOfWeek() throws Exception {</p>
<p class="calibre1">318 //    assertEquals(d(1, JANUARY, 2005),getFollowingDayOfWeek(SATURDAY, d(25, DECEMBER, 2004))); 319     assertEquals(d(1, JANUARY, 2005), getFollowingDayOfWeek(SATURDAY, d(26, DECEMBER, 2004))); 320     assertEquals(d(3, MARCH, 2004), getFollowingDayOfWeek(WEDNESDAY, d(28, FEBRUARY, 2004))); 321</p>
<p class="calibre1">322     try {</p>
<p class="calibre1">323       getFollowingDayOfWeek(-1, d(1, JANUARY, 2006));</p>
<p class="calibre1">324       fail("Invalid day of week code should throw exception"); 325     } catch (IllegalArgumentException e) {</p>
<p class="calibre1">326     }</p>
<p class="calibre1">327   }</p>
<p class="calibre1">328</p>
<p class="calibre1">329   public void testGetNearestDayOfWeek() throws Exception {</p>
<p class="calibre1">330     assertEquals(d(16, APRIL, 2006), getNearestDayOfWeek(SUNDAY, d(16, APRIL, 2006))); 331     assertEquals(d(16, APRIL, 2006), getNearestDayOfWeek(SUNDAY, d(17, APRIL, 2006))); 332     assertEquals(d(16, APRIL, 2006), getNearestDayOfWeek(SUNDAY, d(18, APRIL, 2006))); 333     assertEquals(d(16, APRIL, 2006), getNearestDayOfWeek(SUNDAY, d(19, APRIL, 2006))); 334     assertEquals(d(23, APRIL, 2006), getNearestDayOfWeek(SUNDAY, d(20, APRIL, 2006))); 335     assertEquals(d(23, APRIL, 2006), getNearestDayOfWeek(SUNDAY, d(21, APRIL, 2006))); 336     assertEquals(d(23, APRIL, 2006), getNearestDayOfWeek(SUNDAY, d(22, APRIL, 2006))); 337</p>
<p class="calibre1">338 //todo    assertEquals(d(17, APRIL, 2006), getNearestDayOfWeek(MONDAY, d(16, APRIL, 2006))); 339     assertEquals(d(17, APRIL, 2006), getNearestDayOfWeek(MONDAY, d(17, APRIL, 2006))); 340     assertEquals(d(17, APRIL, 2006), getNearestDayOfWeek(MONDAY, d(18, APRIL, 2006))); 341     assertEquals(d(17, APRIL, 2006), getNearestDayOfWeek(MONDAY, d(19, APRIL, 2006))); 342     assertEquals(d(17, APRIL, 2006), getNearestDayOfWeek(MONDAY, d(20, APRIL, 2006))); 343     assertEquals(d(24, APRIL, 2006), getNearestDayOfWeek(MONDAY, d(21, APRIL, 2006))); 344     assertEquals(d(24, APRIL, 2006), getNearestDayOfWeek(MONDAY, d(22, APRIL, 2006))); 345</p>
<p class="calibre1">346 //    assertEquals(d(18, APRIL, 2006), getNearestDayOfWeek(TUESDAY, d(16, APRIL, 2006))); 347 //    assertEquals(d(18, APRIL, 2006), getNearestDayOfWeek(TUESDAY, d(17, APRIL, 2006))); 348     assertEquals(d(18, APRIL, 2006), getNearestDayOfWeek(TUESDAY, d(18, APRIL, 2006))); 349     assertEquals(d(18, APRIL, 2006), getNearestDayOfWeek(TUESDAY, d(19, APRIL, 2006))); 350     assertEquals(d(18, APRIL, 2006), getNearestDayOfWeek(TUESDAY, d(20, APRIL, 2006))); 351     assertEquals(d(18, APRIL, 2006), getNearestDayOfWeek(TUESDAY, d(21, APRIL, 2006))); 352     assertEquals(d(25, APRIL, 2006), getNearestDayOfWeek(TUESDAY, d(22, APRIL, 2006))); 353</p>
<p class="calibre1">354 //    assertEquals(d(19, APRIL, 2006), getNearestDayOfWeek(WEDNESDAY, d(16, APRIL, 2006))); 355 //    assertEquals(d(19, APRIL, 2006), getNearestDayOfWeek(WEDNESDAY, d(17, APRIL, 2006))); 356 //    assertEquals(d(19, APRIL, 2006), getNearestDayOfWeek(WEDNESDAY, d(18, APRIL, 2006))); 357     assertEquals(d(19, APRIL, 2006), getNearestDayOfWeek(WEDNESDAY, d(19, APRIL, 2006))); 358     assertEquals(d(19, APRIL, 2006), getNearestDayOfWeek(WEDNESDAY, d(20, APRIL, 2006))); 359     assertEquals(d(19, APRIL, 2006), getNearestDayOfWeek(WEDNESDAY, d(21, APRIL, 2006))); 360     assertEquals(d(19, APRIL, 2006), getNearestDayOfWeek(WEDNESDAY, d(22, APRIL, 2006))); 361</p>
<p class="calibre1">362 //    assertEquals(d(13, APRIL, 2006), getNearestDayOfWeek(THURSDAY, d(16, APRIL, 2006))); 363 //    assertEquals(d(20, APRIL, 2006), getNearestDayOfWeek(THURSDAY, d(17, APRIL, 2006))); 364 //    assertEquals(d(20, APRIL, 2006), getNearestDayOfWeek(THURSDAY, d(18, APRIL, 2006))); 365 //    assertEquals(d(20, APRIL, 2006), getNearestDayOfWeek(THURSDAY, d(19, APRIL, 2006))); 366     assertEquals(d(20, APRIL, 2006), getNearestDayOfWeek(THURSDAY, d(20, APRIL, 2006))); 367     assertEquals(d(20, APRIL, 2006), getNearestDayOfWeek(THURSDAY, d(21, APRIL, 2006))); 368     assertEquals(d(20, APRIL, 2006), getNearestDayOfWeek(THURSDAY, d(22, APRIL, 2006))); 369</p>
<p class="calibre1">370 //    assertEquals(d(14, APRIL, 2006), getNearestDayOfWeek(FRIDAY, d(16, APRIL, 2006))); 371 //    assertEquals(d(14, APRIL, 2006), getNearestDayOfWeek(FRIDAY, d(17, APRIL, 2006))); 372 //    assertEquals(d(21, APRIL, 2006), getNearestDayOfWeek(FRIDAY, d(18, APRIL, 2006))); 373 //    assertEquals(d(21, APRIL, 2006), getNearestDayOfWeek(FRIDAY, d(19, APRIL, 2006))); 374 //    assertEquals(d(21, APRIL, 2006), getNearestDayOfWeek(FRIDAY, d(20, APRIL, 2006))); <a id="p411"></a>380</p>
<p class="calibre1"><b class="calibre3">Appendix B: org.jfree.date.SerialDate</b></p>
<p class="calibre1"><b class="calibre3">Listing B-4 (continued)</b></p>
<p class="calibre1"><b class="calibre3">BobsSerialDateTest.java</b></p>
<p class="calibre1">375     assertEquals(d(21, APRIL, 2006), getNearestDayOfWeek(FRIDAY, d(21, APRIL, 2006))); 376     assertEquals(d(21, APRIL, 2006), getNearestDayOfWeek(FRIDAY, d(22, APRIL, 2006))); 377</p>
<p class="calibre1">378 //    assertEquals(d(15, APRIL, 2006), getNearestDayOfWeek(SATURDAY, d(16, APRIL, 2006))); 379 //    assertEquals(d(15, APRIL, 2006), getNearestDayOfWeek(SATURDAY, d(17, APRIL, 2006))); 380 //    assertEquals(d(15, APRIL, 2006), getNearestDayOfWeek(SATURDAY, d(18, APRIL, 2006))); 381 //    assertEquals(d(22, APRIL, 2006), getNearestDayOfWeek(SATURDAY, d(19, APRIL, 2006))); 382 //    assertEquals(d(22, APRIL, 2006), getNearestDayOfWeek(SATURDAY, d(20, APRIL, 2006))); 383 //    assertEquals(d(22, APRIL, 2006), getNearestDayOfWeek(SATURDAY, d(21, APRIL, 2006))); 384     assertEquals(d(22, APRIL, 2006), getNearestDayOfWeek(SATURDAY, d(22, APRIL, 2006))); 385</p>
<p class="calibre1">386     try {</p>
<p class="calibre1">387       getNearestDayOfWeek(-1, d(1, JANUARY, 2006));</p>
<p class="calibre1">388       fail("Invalid day of week code should throw exception"); 389     } catch (IllegalArgumentException e) {</p>
<p class="calibre1">390     }</p>
<p class="calibre1">391   }</p>
<p class="calibre1">392</p>
<p class="calibre1">393   public void testEndOfCurrentMonth() throws Exception {</p>
<p class="calibre1">394     SerialDate d = SerialDate.createInstance(2);</p>
<p class="calibre1">395     assertEquals(d(31, JANUARY, 2006), d.getEndOfCurrentMonth(d(1, JANUARY, 2006))); 396     assertEquals(d(28, FEBRUARY, 2006), d.getEndOfCurrentMonth(d(1, FEBRUARY, 2006))); 397     assertEquals(d(31, MARCH, 2006), d.getEndOfCurrentMonth(d(1, MARCH, 2006))); 398     assertEquals(d(30, APRIL, 2006), d.getEndOfCurrentMonth(d(1, APRIL, 2006))); 399     assertEquals(d(31, MAY, 2006), d.getEndOfCurrentMonth(d(1, MAY, 2006))); 400     assertEquals(d(30, JUNE, 2006), d.getEndOfCurrentMonth(d(1, JUNE, 2006))); 401     assertEquals(d(31, JULY, 2006), d.getEndOfCurrentMonth(d(1, JULY, 2006))); 402     assertEquals(d(31, AUGUST, 2006), d.getEndOfCurrentMonth(d(1, AUGUST, 2006))); 403     assertEquals(d(30, SEPTEMBER, 2006), d.getEndOfCurrentMonth(d(1, SEPTEMBER, 2006))); 404     assertEquals(d(31, OCTOBER, 2006), d.getEndOfCurrentMonth(d(1, OCTOBER, 2006))); 405     assertEquals(d(30, NOVEMBER, 2006), d.getEndOfCurrentMonth(d(1, NOVEMBER, 2006))); 406     assertEquals(d(31, DECEMBER, 2006), d.getEndOfCurrentMonth(d(1, DECEMBER, 2006))); 407     assertEquals(d(29, FEBRUARY, 2008), d.getEndOfCurrentMonth(d(1, FEBRUARY, 2008))); 408   }</p>
<p class="calibre1">409</p>
<p class="calibre1">410   public void testWeekInMonthToString() throws Exception {</p>
<p class="calibre1">411     assertEquals("First",weekInMonthToString(FIRST_WEEK_IN_MONTH)); 412     assertEquals("Second",weekInMonthToString(SECOND_WEEK_IN_MONTH)); 413     assertEquals("Third",weekInMonthToString(THIRD_WEEK_IN_MONTH)); 414     assertEquals("Fourth",weekInMonthToString(FOURTH_WEEK_IN_MONTH)); 415     assertEquals("Last",weekInMonthToString(LAST_WEEK_IN_MONTH)); 416</p>
<p class="calibre1">417 //todo    try {</p>
<p class="calibre1">418 //      weekInMonthToString(-1);</p>
<p class="calibre1">419 //      fail("Invalid week code should throw exception"); 420 //    } catch (IllegalArgumentException e) {</p>
<p class="calibre1">421 //    }</p>
<p class="calibre1">422   }</p>
<p class="calibre1">423</p>
<p class="calibre1">424   public void testRelativeToString() throws Exception {</p>
<p class="calibre1">425     assertEquals("Preceding",relativeToString(PRECEDING)); 426     assertEquals("Nearest",relativeToString(NEAREST)); 427     assertEquals("Following",relativeToString(FOLLOWING)); 428</p>
<p class="calibre1">429 //todo    try {</p>
<p class="calibre1">430 //      relativeToString(-1000);</p>
<p class="calibre1">431 //      fail("Invalid relative code should throw exception"); 432 //    } catch (IllegalArgumentException e) {</p>
<p class="calibre1">433 //    }</p>
<p class="calibre1">434   }</p>
<p class="calibre1">435</p>
<p class="calibre1"><a id="p412"></a><b class="calibre3">Appendix B: org.jfree.date.SerialDate</b></p>
<p class="calibre1">381</p>
<p class="calibre1"><b class="calibre3">Listing B-4 (continued)</b></p>
<p class="calibre1"><b class="calibre3">BobsSerialDateTest.java</b></p>
<p class="calibre1">436   public void testCreateInstanceFromDDMMYYY() throws Exception {</p>
<p class="calibre1">437     SerialDate date = createInstance(1, JANUARY, 1900);</p>
<p class="calibre1">438     assertEquals(1,date.getDayOfMonth());</p>
<p class="calibre1">439     assertEquals(JANUARY,date.getMonth());</p>
<p class="calibre1">440     assertEquals(1900,date.getYYYY());</p>
<p class="calibre1">441     assertEquals(2,date.toSerial());</p>
<p class="calibre1">442   }</p>
<p class="calibre1">443</p>
<p class="calibre1">444   public void testCreateInstanceFromSerial() throws Exception {</p>
<p class="calibre1">445     assertEquals(d(1, JANUARY, 1900),createInstance(2));</p>
<p class="calibre1">446     assertEquals(d(1, JANUARY, 1901), createInstance(367)); 447   }</p>
<p class="calibre1">448</p>
<p class="calibre1">449   public void testCreateInstanceFromJavaDate() throws Exception {</p>
<p class="calibre1">450     assertEquals(d(1, JANUARY, 1900),</p>
<p class="calibre1">createInstance(new GregorianCalendar(1900,0,1).getTime()));</p>
<p class="calibre1">451     assertEquals(d(1, JANUARY, 2006),</p>
<p class="calibre1">createInstance(new GregorianCalendar(2006,0,1).getTime()));</p>
<p class="calibre1">452   }</p>
<p class="calibre1">453</p>
<p class="calibre1">454   public static void main(String[] args) {</p>
<p class="calibre1">455     junit.textui.TestRunner.run(BobsSerialDateTest.class); 456   }</p>
<p class="calibre1">457 }</p>
<p class="calibre1"><a id="p413"></a>382</p>
<p class="calibre1"><b class="calibre3">Appendix B: org.jfree.date.SerialDate</b></p>
<p class="calibre1"><b class="calibre3">Listing B-5 </b></p>
<p class="calibre1"><b class="calibre3">SpreadsheetDate.java</b></p>
<p class="calibre1">1 /* ========================================================================</p>
<p class="calibre1">2  * JCommon : a free general purpose class library for the Java(tm) platform 3  * ========================================================================</p>
<p class="calibre1">4  *</p>
<p class="calibre1">5  * (C) Copyright 2000-2005, by Object Refinery Limited and Contributors.</p>
<p class="calibre1">6  *</p>
<p class="calibre1">7  * Project Info:  http://www.jfree.org/jcommon/index.html</p>
<p class="calibre1">8  *</p>
<p class="calibre1">9  * This library is free software; you can redistribute it and/or modify it 10  * under the terms of the GNU Lesser General Public License as published by 11  * the Free Software Foundation; either version 2.1 of the License, or 12  * (at your option) any later version.</p>
<p class="calibre1">13  *</p>
<p class="calibre1">14  * This library is distributed in the hope that it will be useful, but 15  * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY</p>
<p class="calibre1">16  * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public 17  * License for more details.</p>
<p class="calibre1">18  *</p>
<p class="calibre1">19  * You should have received a copy of the GNU Lesser General Public 20  * License along with this library; if not, write to the Free Software 21  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, 22  * USA.</p>
<p class="calibre1">23  *</p>
<p class="calibre1">24  * [Java is a trademark or registered trademark of Sun Microsystems, Inc.</p>
<p class="calibre1">25  * in the United States and other countries.]</p>
<p class="calibre1">26  *</p>
<p class="calibre1">27  * --------------------</p>
<p class="calibre1">28  * SpreadsheetDate.java</p>
<p class="calibre1">29  * --------------------</p>
<p class="calibre1">30  * (C) Copyright 2000-2005, by Object Refinery Limited and Contributors.</p>
<p class="calibre1">31  *</p>
<p class="calibre1">32  * Original Author:  David Gilbert (for Object Refinery Limited); 33  * Contributor(s):   -;</p>
<p class="calibre1">34  *</p>
<p class="calibre1">35  * $Id: SpreadsheetDate.java,v 1.8 2005/11/03 09:25:39 mungady Exp $</p>
<p class="calibre1">36  *</p>
<p class="calibre1">37  * Changes</p>
<p class="calibre1">38  * -------</p>
<p class="calibre1">39  * 11-Oct-2001 : Version 1 (DG);</p>
<p class="calibre1">40  * 05-Nov-2001 : Added getDescription() and setDescription() methods (DG); 41  * 12-Nov-2001 : Changed name from ExcelDate.java to SpreadsheetDate.java (DG); 42  *               Fixed a bug in calculating day, month and year from serial 43  *               number (DG); 44  * 24-Jan-2002 : Fixed a bug in calculating the serial number from the day, 45  *               month and year.  Thanks to Trevor Hills for the report (DG); 46  * 29-May-2002 : Added equals(Object) method (SourceForge ID 558850) (DG); 47  * 03-Oct-2002 : Fixed errors reported by Checkstyle (DG); 48  * 13-Mar-2003 : Implemented Serializable (DG);</p>
<p class="calibre1">49  * 04-Sep-2003 : Completed isInRange() methods (DG);</p>
<p class="calibre1">50  * 05-Sep-2003 : Implemented Comparable (DG);</p>
<p class="calibre1">51  * 21-Oct-2003 : Added hashCode() method (DG);</p>
<p class="calibre1">52  *</p>
<p class="calibre1">53  */</p>
<p class="calibre1">54</p>
<p class="calibre1">55 package org.jfree.date;</p>
<p class="calibre1">56</p>
<p class="calibre1">57 import java.util.Calendar;</p>
<p class="calibre1">58 import java.util.Date;</p>
<p class="calibre1">59</p>
<p class="calibre1">60 /**</p>
<p class="calibre1">61  * Represents a date using an integer, in a similar fashion to the 62  * implementation in Microsoft Excel.  The range of dates supported is</p>
<p class="calibre1"><a id="p414"></a><b class="calibre3">Appendix B: org.jfree.date.SerialDate</b></p>
<p class="calibre1">383</p>
<p class="calibre1"><b class="calibre3">Listing B-5 (continued)</b></p>
<p class="calibre1"><b class="calibre3">SpreadsheetDate.java</b></p>
<p class="calibre1">63  * 1-Jan-1900 to 31-Dec-9999.</p>
<p class="calibre1">64  * &lt;P&gt;</p>
<p class="calibre1">65  * Be aware that there is a deliberate bug in Excel that recognises the year 66  * 1900 as a leap year when in fact it is not a leap year. You can find more 67  * information on the Microsoft website in article Q181370: 68  * &lt;P&gt; 69  * http://support.microsoft.com/support/kb/articles/Q181/3/70.asp 70  * &lt;P&gt;</p>
<p class="calibre1">71  * Excel uses the convention that 1-Jan-1900 = 1.  This class uses the 72  * convention 1-Jan-1900 = 2.</p>
<p class="calibre1">73  * The result is that the day number in this class will be different to the 74  * Excel figure for January and February 1900...but then Excel adds in an extra 75  * day (29-Feb-1900 which does not actually exist!) and from that point forward 76  * the day numbers will match.</p>
<p class="calibre1">77  *</p>
<p class="calibre1">78  * @author David Gilbert</p>
<p class="calibre1">79  */</p>
<p class="calibre1">80 public class SpreadsheetDate extends SerialDate {</p>
<p class="calibre1">81</p>
<p class="calibre1">82     /** For serialization. */</p>
<p class="calibre1">83     private static final long serialVersionUID = -2039586705374454461L; 84</p>
<p class="calibre1">85     /**</p>
<p class="calibre1">86      * The day number (1-Jan-1900 = 2, 2-Jan-1900 = 3, ..., 31-Dec-9999 =</p>
<p class="calibre1">87      * 2958465).</p>
<p class="calibre1">88      */</p>
<p class="calibre1">89     private int serial;</p>
<p class="calibre1">90</p>
<p class="calibre1">91     /** The day of the month (1 to 28, 29, 30 or 31 depending on the month). */</p>
<p class="calibre1">92     private int day;</p>
<p class="calibre1">93</p>
<p class="calibre1">94     /** The month of the year (1 to 12). */</p>
<p class="calibre1">95     private int month;</p>
<p class="calibre1">96</p>
<p class="calibre1">97     /** The year (1900 to 9999). */</p>
<p class="calibre1">98     private int year;</p>
<p class="calibre1">99</p>
<p class="calibre1">100     /** An optional description for the date. */</p>
<p class="calibre1">101     private String description;</p>
<p class="calibre1">102</p>
<p class="calibre1">103     /**</p>
<p class="calibre1">104      * Creates a new date instance.</p>
<p class="calibre1">105      *</p>
<p class="calibre1">106      * @param day  the day (in the range 1 to 28/29/30/31).</p>
<p class="calibre1">107      * @param month  the month (in the range 1 to 12).</p>
<p class="calibre1">108      * @param year  the year (in the range 1900 to 9999).</p>
<p class="calibre1">109      */</p>
<p class="calibre1">110     public SpreadsheetDate(final int day, final int month, final int year) {</p>
<p class="calibre1">111</p>
<p class="calibre1">112         if ((year &gt;= 1900) &amp;&amp; (year &lt;= 9999)) {</p>
<p class="calibre1">113             this.year = year;</p>
<p class="calibre1">114         }</p>
<p class="calibre1">115         else {</p>
<p class="calibre1">116             throw new IllegalArgumentException(</p>
<p class="calibre1">117                 "The 'year' argument must be in range 1900 to 9999."</p>
<p class="calibre1">118             );</p>
<p class="calibre1">119         }</p>
<p class="calibre1">120</p>
<p class="calibre1">121         if ((month &gt;= MonthConstants.JANUARY)</p>
<p class="calibre1">122                 &amp;&amp; (month &lt;= MonthConstants.DECEMBER)) {</p>
<p class="calibre1">123             this.month = month;</p>
<p class="calibre1">124         }</p>
<p class="calibre1"><a id="p415"></a>384</p>
<p class="calibre1"><b class="calibre3">Appendix B: org.jfree.date.SerialDate</b></p>
<p class="calibre1"><b class="calibre3">Listing B-5 (continued)</b></p>
<p class="calibre1"><b class="calibre3">SpreadsheetDate.java</b></p>
<p class="calibre1">125         else {</p>
<p class="calibre1">126             throw new IllegalArgumentException(</p>
<p class="calibre1">127                 "The 'month' argument must be in the range 1 to 12."</p>
<p class="calibre1">128             );</p>
<p class="calibre1">129         }</p>
<p class="calibre1">130</p>
<p class="calibre1">131         if ((day &gt;= 1) &amp;&amp; (day &lt;= SerialDate.lastDayOfMonth(month, year))) {</p>
<p class="calibre1">132             this.day = day;</p>
<p class="calibre1">133         }</p>
<p class="calibre1">134         else {</p>
<p class="calibre1">135             throw new IllegalArgumentException("Invalid 'day' argument."); 136         }</p>
<p class="calibre1">137</p>
<p class="calibre1">138         // the serial number needs to be synchronised with the day-month-year...</p>
<p class="calibre1">139         this.serial = calcSerial(day, month, year);</p>
<p class="calibre1">140</p>
<p class="calibre1">141         this.description = null;</p>
<p class="calibre1">142</p>
<p class="calibre1">143     }</p>
<p class="calibre1">144</p>
<p class="calibre1">145     /**</p>
<p class="calibre1">146      * Standard constructor - creates a new date object representing the 147      * specified day number (which should be in the range 2 to 2958465.</p>
<p class="calibre1">148      *</p>
<p class="calibre1">149      * @param serial  the serial number for the day (range: 2 to 2958465).</p>
<p class="calibre1">150      */</p>
<p class="calibre1">151     public SpreadsheetDate(final int serial) {</p>
<p class="calibre1">152</p>
<p class="calibre1">153         if ((serial &gt;= SERIAL_LOWER_BOUND) &amp;&amp; (serial &lt;= SERIAL_UPPER_BOUND)) {</p>
<p class="calibre1">154             this.serial = serial;</p>
<p class="calibre1">155         }</p>
<p class="calibre1">156         else {</p>
<p class="calibre1">157             throw new IllegalArgumentException(</p>
<p class="calibre1">158                 "SpreadsheetDate: Serial must be in range 2 to 2958465."); 159         }</p>
<p class="calibre1">160</p>
<p class="calibre1">161         // the day-month-year needs to be synchronised with the serial number...</p>
<p class="calibre1">162         calcDayMonthYear();</p>
<p class="calibre1">163</p>
<p class="calibre1">164     }</p>
<p class="calibre1">165</p>
<p class="calibre1">166     /**</p>
<p class="calibre1">167      * Returns the description that is attached to the date.  It is not 168      * required that a date have a description, but for some applications it 169      * is useful.</p>
<p class="calibre1">170      *</p>
<p class="calibre1">171      * @return The description that is attached to the date.</p>
</body>
</html>
