<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <title>index</title>
    <meta name="generator" content="pdftohtml 0.36"/>
    <meta name="date" content="2009-10-16T23:21:09+00:00"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="calibre">
<h2 class="calibre5" id="calibre_pb_158">Chapter 11: Systems</h2>
<p class="calibre1"><b class="calibre3">Listing 11-5 (continued)</b></p>
<p class="calibre1"><b class="calibre3">An EBJ3 Bank EJB</b></p>
<p class="calibre1">public void setAccounts(Collection&lt;Account&gt; accounts) {</p>
<p class="calibre1">this.accounts = accounts;</p>
<p class="calibre1">}</p>
<p class="calibre1">}</p>
<p class="calibre1">This code is much cleaner than the original EJB2 code. Some of the entity details are still here, contained in the annotations. However, because none of that information is outside of the annotations, the code is clean, clear, and hence easy to test drive, maintain, and so on.</p>
<p class="calibre1">Some or all of the persistence information in the annotations can be moved to XML</p>
<p class="calibre1">deployment descriptors, if desired, leaving a truly pure POJO. If the persistence mapping details won’t change frequently, many teams may choose to keep the annotations, but with far fewer harmful drawbacks compared to the EJB2 invasiveness.</p>
<p class="calibre1"><a href="index_split_000.html#p13"><b class="calibre3">AspectJ Aspects</b></a></p>
<p class="calibre1">Finally, the most full-featured tool for separating concerns through aspects is the AspectJ</p>
<p class="calibre1">language,17 an extension of Java that provides “first-class” support for aspects as modularity constructs. The pure Java approaches provided by Spring AOP and JBoss AOP are sufficient for 80–90 percent of the cases where aspects are most useful. However, AspectJ</p>
<p class="calibre1">provides a very rich and powerful tool set for separating concerns. The drawback of AspectJ is the need to adopt several new tools and to learn new language constructs and usage idioms.</p>
<p class="calibre1">The adoption issues have been partially mitigated by a recently introduced “annotation form” of AspectJ, where Java 5 annotations are used to define aspects using pure Java code. Also, the Spring Framework has a number of features that make incorporation of annotation-based aspects much easier for a team with limited AspectJ experience.</p>
<p class="calibre1">A full discussion of AspectJ is beyond the scope of this book. See [AspectJ], [Colyer], and [Spring] for more information.</p>
<p class="calibre1"><a href="index_split_000.html#p13"><b class="calibre3">Test Drive the System Architecture</b></a></p>
<p class="calibre1">The power of separating concerns through aspect-like approaches can’t be overstated. If you can write your application’s domain logic using POJOs, decoupled from any architecture concerns at the code level, then it is possible to truly  <i class="calibre4">test drive </i> your architecture. You can evolve it from simple to sophisticated, as needed, by adopting new technologies on 17. See [AspectJ] and [Colyer].</p>
<p class="calibre1"><a id="p198"></a><b class="calibre3">Optimize Decision Making</b></p>
<p class="calibre1">167</p>
<p class="calibre1">demand. It is not necessary to do a  <i class="calibre4">Big Design Up Front</i> 18 (BDUF). In fact, BDUF is even harmful because it inhibits adapting to change, due to the psychological resistance to discarding prior effort and because of the way architecture choices influence subsequent thinking about the design.</p>
<p class="calibre1">Building architects have to do BDUF because it is not feasible to make radical architectural changes to a large physical structure once construction is well underway.19</p>
<p class="calibre1">Although software has its own  <i class="calibre4">physics</i>,20 it is economically feasible to make radical change,  <i class="calibre4">if </i> the structure of the software separates its concerns effectively.</p>
<p class="calibre1">This means we can start a software project with a “naively simple” but nicely decoupled architecture, delivering working user stories quickly, then adding more infrastructure as we scale up. Some of the world’s largest Web sites have achieved very high availability and performance, using sophisticated data caching, security, virtualization, and so forth, all done efficiently and flexibly because the minimally coupled designs are appropriately <i class="calibre4">simple</i> at each level of abstraction and scope.</p>
<p class="calibre1">Of course, this does not mean that we go into a project “rudderless.” We have some expectations of the general scope, goals, and schedule for the project, as well as the general structure of the resulting system. However, we must maintain the ability to change course in response to evolving circumstances.</p>
<p class="calibre1">The early EJB architecture is but one of many well-known APIs that are over-engineered and that compromise separation of concerns. Even well-designed APIs can be over-kill when they aren’t really needed. A good API should largely  <i class="calibre4">disappear </i> from view most of the time, so the team expends the majority of its creative efforts focused on the user stories being implemented. If not, then the architectural constraints will inhibit the efficient delivery of optimal value to the customer.</p>
<p class="calibre1">To recap this long discussion,</p>
<p class="calibre1"><i class="calibre4">An optimal system architecture consists of modularized domains of concern, each of which</i> <i class="calibre4">is implemented with Plain Old Java (or other) Objects. The different domains are integrated together with minimally invasive Aspects or Aspect-like tools. This architecture can</i> <i class="calibre4">be test-driven, just like the code. </i></p>
<p class="calibre1"><a href="index_split_000.html#p13"><b class="calibre3">Optimize Decision Making</b></a></p>
<p class="calibre1">Modularity and separation of concerns make decentralized management and decision making possible. In a sufficiently large system, whether it is a city or a software project, no one person can make all the decisions.</p>
<p class="calibre1">18. Not to be confused with the good practice of up-front design, BDUF is the practice of designing  <i class="calibre4">everything</i> up front before implementing anything at all.</p>
<p class="calibre1">19. There is still a significant amount of iterative exploration and discussion of details, even after construction starts.</p>
<p class="calibre1">20. The term  <i class="calibre4">software physics</i> was first used by [Kolence].</p>
<p class="calibre1"><a id="p199"></a>168</p>
<div class="calibre6" id="calibre_pb_159"></div>
</body>
</html>
