<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <title>index</title>
    <meta name="generator" content="pdftohtml 0.36"/>
    <meta name="date" content="2009-10-16T23:21:09+00:00"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="calibre">
<h2 class="calibre5" id="calibre_pb_46">Chapter 3: Functions</h2>
<p class="calibre1">to add new errors because then they have to rebuild and redeploy everything. So they reuse old error codes instead of adding new ones.</p>
<p class="calibre1">When you use exceptions rather than error codes, then new exceptions are  <i class="calibre4">derivatives </i> of the exception class. They can be added without forcing any recompilation or redeployment.12</p>
<p class="calibre1"><a href="index_split_000.html#p10"><b class="calibre3">Don’t Repeat Yourself13</b></a></p>
<p class="calibre1">Look back at Listing 3-1 carefully and you</p>
<p class="calibre1">will notice that there is an algorithm that</p>
<p class="calibre1">gets repeated four times, once for each of</p>
<p class="calibre1">the</p>
<p class="calibre1">SetUp,</p>
<p class="calibre1">SuiteSetUp,</p>
<p class="calibre1">TearDown, and</p>
<p class="calibre1">SuiteTearDown cases. It’s not easy to spot</p>
<p class="calibre1">this duplication because the four instances</p>
<p class="calibre1">are intermixed with other code and aren’t</p>
<p class="calibre1">uniformly duplicated. Still, the duplication</p>
<p class="calibre1">is a problem because it bloats the code and</p>
<p class="calibre1">will require four-fold modification should the algorithm ever have to change. It is also a four-fold opportunity for an error of omission.</p>
<p class="calibre1">This duplication was remedied by the include method in Listing 3-7. Read through that code again and notice how the readability of the whole module is enhanced by the reduction of that duplication.</p>
<p class="calibre1">Duplication may be the root of all evil in software. Many principles and practices have been created for the purpose of controlling or eliminating it. Consider, for example, that all of Codd’s database normal forms serve to eliminate duplication in data. Consider also how object-oriented programming serves to concentrate code into base classes that would otherwise be redundant. Structured programming, Aspect Oriented Programming, Component Oriented Programming, are all, in part, strategies for eliminating duplication. It would appear that since the invention of the subroutine, innovations in software development have been an ongoing attempt to eliminate duplication from our source code.</p>
<p class="calibre1"><a href="index_split_000.html#p10"><b class="calibre3">Structured Programming</b></a></p>
<p class="calibre1">Some programmers follow Edsger Dijkstra’s rules of structured programming.14 Dijkstra said that every function, and every block within a function, should have one entry and one exit. Following these rules means that there should only be one return statement in a function, no break or continue statements in a loop, and never,  <i class="calibre4">ever, </i> any goto statements.</p>
<p class="calibre1">12. This is an example of the Open Closed Principle (OCP) [PPP02].</p>
<p class="calibre1">13. The DRY principle. [PRAG].</p>
<p class="calibre1">14. [SP72].</p>
<p class="calibre1"><a id="p80"></a><b class="calibre3">Conclusion</b></p>
<p class="calibre1">49</p>
<p class="calibre1">While we are sympathetic to the goals and disciplines of structured programming, those rules serve little benefit when functions are very small. It is only in larger functions that such rules provide significant benefit.</p>
<p class="calibre1">So if you keep your functions small, then the occasional multiple return, break, or continue statement does no harm and can sometimes even be more expressive than the single-entry, single-exit rule. On the other hand, goto only makes sense in large functions, so it should be avoided.</p>
<p class="calibre1"><a href="index_split_000.html#p10"><b class="calibre3">How Do You Write Functions Like This? </b></a></p>
<p class="calibre1">Writing software is like any other kind of writing. When you write a paper or an article, you get your thoughts down first, then you massage it until it reads well. The first draft might be clumsy and disorganized, so you wordsmith it and restructure it and refine it until it reads the way you want it to read.</p>
<p class="calibre1">When I write functions, they come out long and complicated. They have lots of indenting and nested loops. They have long argument lists. The names are arbitrary, and there is duplicated code. But I also have a suite of unit tests that cover every one of those clumsy lines of code.</p>
<p class="calibre1">So then I massage and refine that code, splitting out functions, changing names, eliminating duplication. I shrink the methods and reorder them. Sometimes I break out whole classes, all the while keeping the tests passing.</p>
<p class="calibre1">In the end, I wind up with functions that follow the rules I’ve laid down in this chapter.</p>
<p class="calibre1">I don’t write them that way to start. I don’t think anyone could.</p>
<p class="calibre1"><a href="index_split_000.html#p10"><b class="calibre3">Conclusion</b></a></p>
<p class="calibre1">Every system is built from a domain-specific language designed by the programmers to describe that system. Functions are the verbs of that language, and classes are the nouns.</p>
<p class="calibre1">This is not some throwback to the hideous old notion that the nouns and verbs in a requirements document are the first guess of the classes and functions of a system. Rather, this is a much older truth. The art of programming is, and has always been, the art of language design.</p>
<p class="calibre1">Master programmers think of systems as stories to be told rather than programs to be written. They use the facilities of their chosen programming language to construct a much richer and more expressive language that can be used to tell that story. Part of that domain-specific language is the hierarchy of functions that describe all the actions that take place within that system. In an artful act of recursion those actions are written to use the very domain-specific language they define to tell their own small part of the story.</p>
<p class="calibre1">This chapter has been about the mechanics of writing functions well. If you follow the rules herein, your functions will be short, well named, and nicely organized. But</p>
<p class="calibre1"><a id="p81"></a>50</p>
<div class="calibre6" id="calibre_pb_47"></div>
</body>
</html>
