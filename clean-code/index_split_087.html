<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <title>index</title>
    <meta name="generator" content="pdftohtml 0.36"/>
    <meta name="date" content="2009-10-16T23:21:09+00:00"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="calibre">
<h2 class="calibre5" id="calibre_pb_172">Chapter 13: Concurrency</h2>
<p class="calibre1">•  <i class="calibre4">Concurrency bugs aren’t usually repeatable, </i> so they are often ignored as one-offs2</p>
<p class="calibre1">instead of the true defects they are.</p>
<p class="calibre1">•  <i class="calibre4">Concurrency often requires a fundamental change in design strategy</i>.</p>
<p class="calibre1"><a href="index_split_000.html#p14"><b class="calibre3">Challenges</b></a></p>
<p class="calibre1">What makes concurrent programming so difficult? Consider the following trivial class: public class X {</p>
<p class="calibre1">private int lastIdUsed;</p>
<p class="calibre1">public int getNextId() {</p>
<p class="calibre1">return ++lastIdUsed;</p>
<p class="calibre1">}</p>
<p class="calibre1">}</p>
<p class="calibre1">Let’s say we create an instance of X, set the lastIdUsed field to 42, and then share the instance between two threads. Now suppose that both of those threads call the method getNextId(); there are three possible outcomes: • Thread one gets the value 43, thread two gets the value 44, lastIdUsed is 44.</p>
<p class="calibre1">• Thread one gets the value 44, thread two gets the value 43, lastIdUsed is 44.</p>
<p class="calibre1">• Thread one gets the value 43, thread two gets the value 43, lastIdUsed is 43.</p>
<p class="calibre1">The surprising third result3 occurs when the two threads step on each other. This happens because there are many possible paths that the two threads can take through that one line of Java code, and some of those paths generate incorrect results. How many different paths are there? To really answer that question, we need to understand what the Just-In-Time Compiler does with the generated byte-code, and understand what the Java memory model considers to be atomic.</p>
<p class="calibre1">A quick answer, working with just the generated byte-code, is that there are 12,870</p>
<p class="calibre1">different possible execution paths4 for those two threads executing within the getNextId method. If the type of lastIdUsed is changed from int to long, the number of possible paths increases to 2,704,156. Of course most of those paths generate valid results. The problem is that  <i class="calibre4">some of them don’t</i>.</p>
<p class="calibre1"><a href="index_split_000.html#p14"><b class="calibre3">Concurrency Defense Principles</b></a></p>
<p class="calibre1">What follows is a series of principles and techniques for defending your systems from the problems of concurrent code.</p>
<p class="calibre1">2. Cosmic-rays, glitches, and so on.</p>
<p class="calibre1">3. See “Digging Deeper” on page 323.</p>
<p class="calibre1">4. See “Possible Paths of Execution” on page 321.</p>
<p class="calibre1"><a id="p212"></a><b class="calibre3">Concurrency Defense Principles</b></p>
<p class="calibre1">181</p>
<p class="calibre1"><a href="index_split_000.html#p14"><b class="calibre3">Single Responsibility Principle</b></a></p>
<p class="calibre1">The SRP5 states that a given method/class/component should have a single reason to change. Concurrency design is complex enough to be a reason to change in it’s own right and therefore deserves to be separated from the rest of the code. Unfortunately, it is all too common for concurrency implementation details to be embedded directly into other production code. Here are a few things to consider: •  <i class="calibre4">Concurrency-related code has its own life cycle of development, </i> change, and tuning.</p>
<p class="calibre1">•  <i class="calibre4">Concurrency-related code has its own challenges, </i> which are different from and often more difficult than nonconcurrency-related code.</p>
<p class="calibre1">• The number of ways in which miswritten concurrency-based code can fail makes it challenging enough without the added burden of surrounding application code.</p>
<p class="calibre1"><b class="calibre3">Recommendation</b>:  <i class="calibre4">Keep your concurrency-related code separate from other code</i>.6</p>
<p class="calibre1"><a href="index_split_000.html#p14"><b class="calibre3">Corollary: Limit the Scope of Data</b></a></p>
<p class="calibre1">As we saw, two threads modifying the same field of a shared object can interfere with each other, causing unexpected behavior. One solution is to use the synchronized keyword to protect a  <i class="calibre4">critical section </i> in the code that uses the shared object. It is important to restrict the number of such critical sections. The more places shared data can get updated, the more likely: • You will forget to protect one or more of those places—effectively breaking all code that modifies that shared data.</p>
<p class="calibre1">• There will be duplication of effort required to make sure everything is effectively guarded (violation of DRY7).</p>
<p class="calibre1">• It will be difficult to determine the source of failures, which are already hard enough to find.</p>
<p class="calibre1"><b class="calibre3">Recommendation</b>:  <i class="calibre4">Take data encapsulation to heart; severely limit the access of any</i> <i class="calibre4">data that may be shared. </i></p>
<p class="calibre1"><a href="index_split_000.html#p14"><b class="calibre3">Corollary: Use Copies of Data</b></a></p>
<p class="calibre1">A good way to avoid shared data is to avoid sharing the data in the first place. In some situations it is possible to copy objects and treat them as read-only. In other cases it might be possible to copy objects, collect results from multiple threads in these copies and then merge the results in a single thread.</p>
<p class="calibre1">5. [PPP]</p>
<p class="calibre1">6. See “Client/Server Example” on page 317.</p>
<p class="calibre1">7. [PRAG].</p>
<p class="calibre1"><a id="p213"></a>182</p>
<div class="calibre6" id="calibre_pb_173"></div>
</body>
</html>
