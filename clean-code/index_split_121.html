<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <title>index</title>
    <meta name="generator" content="pdftohtml 0.36"/>
    <meta name="date" content="2009-10-16T23:21:09+00:00"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="calibre">
<h2 class="calibre5" id="calibre_pb_240">Chapter 14: Successive Refinement</h2>
<p class="calibre1">The majority of the changes to the Args class were deletions. A lot of code just got moved out of Args and put into ArgsException. Nice. We also moved all the ArgumentMarshallers into their own files. Nicer!</p>
<p class="calibre1">Much of good software design is simply about partitioning—creating appropriate places to put different kinds of code. This separation of concerns makes the code much simpler to understand and maintain.</p>
<p class="calibre1">Of special interest is the errorMessage method of ArgsException. Clearly it was a violation of the SRP to put the error message formatting into Args. Args should be about the processing of arguments, not about the format of the error messages. However, does it really make sense to put the error message formatting code into ArgsException?</p>
<p class="calibre1">Frankly, it’s a compromise. Users who don’t like the error messages supplied by ArgsException will have to write their own. But the convenience of having canned error messages already prepared for you is not insignificant.</p>
<p class="calibre1">By now it should be clear that we are within striking distance of the final solution that appeared at the start of this chapter. I’ll leave the final transformations to you as an exercise.</p>
<p class="calibre1"><a href="index_split_000.html#p14"><b class="calibre3"> Conclusion</b></a></p>
<p class="calibre1">It is not enough for code to work. Code that works is often badly broken. Programmers who satisfy themselves with merely working code are behaving unprofessionally. They may fear that they don’t have time to improve the structure and design of their code, but I disagree. Nothing has a more profound and long-term degrading effect upon a development project than bad code. Bad schedules can be redone, bad requirements can be redefined. Bad team dynamics can be repaired. But bad code rots and ferments, becoming an inexorable weight that drags the team down. Time and time again I have seen teams grind to a crawl because, in their haste, they created a malignant morass of code that forever thereafter dominated their destiny.</p>
<p class="calibre1">Of course bad code can be cleaned up. But it’s very expensive. As code rots, the modules insinuate themselves into each other, creating lots of hidden and tangled dependencies. Finding and breaking old dependencies is a long and arduous task. On the other hand, keeping code clean is relatively easy. If you made a mess in a module in the morning, it is easy to clean it up in the afternoon. Better yet, if you made a mess five minutes ago, it’s very easy to clean it up right now.</p>
<p class="calibre1">So the solution is to continuously keep your code as clean and simple as it can be.</p>
<p class="calibre1">Never let the rot get started.</p>
<p class="calibre1"><a id="p282"></a><img src="index-282_1.png" alt="Image 45" class="calibre2"/></p>
<p class="calibre1"><a href="index_split_000.html#p15"><b class="calibre3">15</b></a></p>
<p class="calibre1"><a href="index_split_000.html#p15"><b class="calibre3">JUnit Internals</b></a></p>
<p class="calibre1">JUnit is one of the most famous of all Java frameworks. As frameworks go, it is simple in conception, precise in definition, and elegant in implementation. But what does the code look like? In this chapter we’ll critique an example drawn from the JUnit framework.</p>
<p class="calibre1">251</p>
<p class="calibre1"><a id="p283"></a>252</p>
<div class="calibre6" id="calibre_pb_241"></div>
</body>
</html>
