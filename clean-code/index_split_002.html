<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <title>index</title>
    <meta name="generator" content="pdftohtml 0.36"/>
    <meta name="date" content="2009-10-16T23:21:09+00:00"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="calibre">
<h2 class="calibre5" id="calibre_pb_2">Chapter 1: Clean Code</h2>
<p class="calibre1">This is a book about good programming. It is filled with code. We are going to look at code from every different direction. We’ll look down at it from the top, up at it from the bottom, and through it from the inside out. By the time we are done, we’re going to know a lot about code. What’s more, we’ll be able to tell the difference between good code and bad code. We’ll know how to write good code. And we’ll know how to transform bad code into good code.</p>
<p class="calibre1"><a href="index_split_000.html#p8"><b class="calibre3">There Will Be Code</b></a></p>
<p class="calibre1">One might argue that a book about code is somehow behind the times—that code is no longer the issue; that we should be concerned about models and requirements instead.</p>
<p class="calibre1">Indeed some have suggested that we are close to the end of code. That soon all code will be generated instead of written. That programmers simply won’t be needed because business people will generate programs from specifications.</p>
<p class="calibre1">Nonsense! We will never be rid of code, because code represents the details of the requirements. At some level those details cannot be ignored or abstracted; they have to be specified. And specifying requirements in such detail that a machine can execute them  <i class="calibre4">is</i> <i class="calibre4">programming</i>. Such a specification  <i class="calibre4">is code</i>.</p>
<p class="calibre1">I expect that the level of abstraction of our languages will continue to increase. I also expect that the number of domain-specific languages will continue to grow. This will be a good thing. But it will not eliminate code. Indeed, all the specifications written in these higher level and domain-specific language will  <i class="calibre4">be </i> code! It will still need to be rigorous, accurate, and so formal and detailed that a machine can understand and execute it.</p>
<p class="calibre1">The folks who think that code will one day disappear are like mathematicians who hope one day to discover a mathematics that does not have to be formal. They are hoping that one day we will discover a way to create machines that can do what we want rather than what we say. These machines will have to be able to understand us so well that they can translate vaguely specified needs into perfectly executing programs that precisely meet those needs.</p>
<p class="calibre1">This will never happen. Not even humans, with all their intuition and creativity, have been able to create successful systems from the vague feelings of their customers.</p>
<p class="calibre1">Indeed, if the discipline of requirements specification has taught us anything, it is that well-specified requirements are as formal as code and can act as executable tests of that code!</p>
<p class="calibre1">Remember that code is really the language in which we ultimately express the requirements. We may create languages that are closer to the requirements. We may create tools that help us parse and assemble those requirements into formal structures. But we will never eliminate necessary precision—so there will always be code.</p>
<p class="calibre1"><a id="p34"></a><img src="index-34_1.png" alt="Image 7" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">Bad Code</b></p>
<p class="calibre1">3</p>
<p class="calibre1"><a href="index_split_000.html#p8"><b class="calibre3">Bad Code</b></a></p>
<p class="calibre1">I was recently reading the preface to Kent Beck’s</p>
<p class="calibre1">book  <i class="calibre4">Implementation Patterns. </i> 1 He says, “. . . this</p>
<p class="calibre1">book is based on a rather fragile premise: that</p>
<p class="calibre1">good code matters. . . .” A  <i class="calibre4">fragile </i> premise? I dis-</p>
<p class="calibre1">agree! I think that premise is one of the most</p>
<p class="calibre1">robust, supported, and overloaded of all the pre-</p>
<p class="calibre1">mises in our craft (and I think Kent knows it). We</p>
<p class="calibre1">know good code matters because we’ve had to</p>
<p class="calibre1">deal for so long with its lack.</p>
<p class="calibre1">I know of one company that, in the late 80s,</p>
<p class="calibre1">wrote a  <i class="calibre4">killer </i> app. It was very popular, and lots of</p>
<p class="calibre1">professionals bought and used it. But then the</p>
<p class="calibre1">release cycles began to stretch. Bugs were not</p>
<p class="calibre1">repaired from one release to the next. Load times</p>
<p class="calibre1">grew and crashes increased. I remember the day I</p>
<p class="calibre1">shut the product down in frustration and never</p>
<p class="calibre1">used it again. The company went out of business</p>
<p class="calibre1">a short time after that.</p>
<p class="calibre1">Two decades later I met one of the early employees of that company and asked him what had happened. The answer confirmed my fears. They had rushed the product to market and had made a huge mess in the code. As they added more and more features, the code got worse and worse until they simply could not manage it any longer.  <i class="calibre4">It was the bad</i> <i class="calibre4">code that brought the company down. </i></p>
<p class="calibre1">Have  <i class="calibre4">you </i> ever been significantly impeded by bad code? If you are a programmer of any experience then you’ve felt this impediment many times. Indeed, we have a name for it. We call it  <i class="calibre4">wading</i>. We wade through bad code. We slog through a morass of tangled brambles and hidden pitfalls. We struggle to find our way, hoping for some hint, some clue, of what is going on; but all we see is more and more senseless code.</p>
<p class="calibre1">Of course you have been impeded by bad code. So then—why did you write it?</p>
<p class="calibre1">Were you trying to go fast? Were you in a rush? Probably so. Perhaps you felt that you didn’t have time to do a good job; that your boss would be angry with you if you took the time to clean up your code. Perhaps you were just tired of working on this program and wanted it to be over. Or maybe you looked at the backlog of other stuff that you had promised to get done and realized that you needed to slam this module together so you could move on to the next. We’ve all done it.</p>
<p class="calibre1">We’ve all looked at the mess we’ve just made and then have chosen to leave it for another day. We’ve all felt the relief of seeing our messy program work and deciding that a 1.</p>
<p class="calibre1">[Beck07].</p>
<p class="calibre1"><a id="p35"></a><img src="index-35_1.jpg" alt="Image 8" class="calibre2"/></p>
<p class="calibre1">4</p>
<div class="calibre6" id="calibre_pb_3"></div>
</body>
</html>
