<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <title>index</title>
    <meta name="generator" content="pdftohtml 0.36"/>
    <meta name="date" content="2009-10-16T23:21:09+00:00"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="calibre">
<h2 class="calibre5" id="calibre_pb_116">Chapter 8: Boundaries</h2>
<p class="calibre1"><a href="index_split_000.html#p12"><b class="calibre3">Clean Boundaries</b></a></p>
<p class="calibre1">Interesting things happen at boundaries. Change is one of those things. Good software designs accommodate change without huge investments and rework. When we use code that is out of our control, special care must be taken to protect our investment and make sure future change is not too costly.</p>
<p class="calibre1">Code at the boundaries needs clear separation and tests that define expectations. We should avoid letting too much of our code know about the third-party particulars. It’s better to depend on something  <i class="calibre4">you </i> control than on something you don’t control, lest it end up controlling you.</p>
<p class="calibre1">We manage third-party boundaries by having very few places in the code that refer to them. We may wrap them as we did with Map, or we may use an ADAPTER to convert from our perfect interface to the provided interface. Either way our code speaks to us better, promotes internally consistent usage across the boundary, and has fewer maintenance points when the third-party code changes.</p>
<p class="calibre1"><a href="index_split_000.html#p12"><b class="calibre3">Bibliography</b></a></p>
<p class="calibre1"><b class="calibre3">[BeckTDD]:  </b> <i class="calibre4">Test Driven Development, </i> Kent Beck, Addison-Wesley, 2003.</p>
<p class="calibre1"><b class="calibre3">[GOF]:  </b> <i class="calibre4">Design Patterns: Elements of Reusable Object Oriented Software, </i> Gamma et al., Addison-Wesley, 1996.</p>
<p class="calibre1"><b class="calibre3">[WELC]:  </b> <i class="calibre4">Working Effectively with Legacy Code, </i> Addison-Wesley, 2004.</p>
<p class="calibre1"><a id="p152"></a><img src="index-152_1.png" alt="Image 36" class="calibre2"/></p>
<p class="calibre1"><a href="index_split_000.html#p12"><b class="calibre3">9</b></a></p>
<p class="calibre1"><a href="index_split_000.html#p12"><b class="calibre3">Unit Tests</b></a></p>
<p class="calibre1">Our profession has come a long way in the last ten years. In 1997 no one had heard of Test Driven Development. For the vast majority of us, unit tests were short bits of throw-away code that we wrote to make sure our programs “worked.” We would painstakingly write our classes and methods, and then we would concoct some ad hoc code to test them. Typically this would involve some kind of simple driver program that would allow us to manually interact with the program we had written.</p>
<p class="calibre1">I remember writing a C++ program for an embedded real-time system back in the mid-90s. The program was a simple timer with the following signature: void Timer::ScheduleCommand(Command* theCommand, int milliseconds) The idea was simple; the execute method of the Command would be executed in a new thread after the specified number of milliseconds. The problem was, how to test it.</p>
<p class="calibre1">121</p>
<p class="calibre1"><a id="p153"></a>122</p>
<div class="calibre6" id="calibre_pb_117"></div>
</body>
</html>
