<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <title>index</title>
    <meta name="generator" content="pdftohtml 0.36"/>
    <meta name="date" content="2009-10-16T23:21:09+00:00"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="calibre">
<h2 class="calibre5" id="calibre_pb_144">Chapter 10: Classes</h2>
<p class="calibre1">We design TokyoStockExchange to implement this interface. We also make sure that the constructor of Portfolio takes a StockExchange reference as an argument: public Portfolio {</p>
<p class="calibre1">private StockExchange exchange;</p>
<p class="calibre1">public Portfolio(StockExchange exchange) {</p>
<p class="calibre1">this.exchange = exchange;</p>
<p class="calibre1">}</p>
<p class="calibre1">// ...</p>
<p class="calibre1">}</p>
<p class="calibre1">Now our test can create a testable implementation of the StockExchange interface that emulates the TokyoStockExchange. This test implementation will fix the current value for any symbol we use in testing. If our test demonstrates purchasing five shares of Microsoft for our portfolio, we code the test implementation to always return $100 per share of Microsoft. Our test implementation of the StockExchange interface reduces to a simple table lookup. We can then write a test that expects $500 for our overall portfolio value.</p>
<p class="calibre1">public class PortfolioTest {</p>
<p class="calibre1">private FixedStockExchangeStub exchange;</p>
<p class="calibre1">private Portfolio portfolio;</p>
<p class="calibre1">@Before</p>
<p class="calibre1">protected void setUp() throws Exception {</p>
<p class="calibre1">exchange = new FixedStockExchangeStub();</p>
<p class="calibre1">exchange.fix("MSFT", 100);</p>
<p class="calibre1">portfolio = new Portfolio(exchange);</p>
<p class="calibre1">}</p>
<p class="calibre1">@Test</p>
<p class="calibre1">public void GivenFiveMSFTTotalShouldBe500() throws Exception {</p>
<p class="calibre1">portfolio.add(5, "MSFT");</p>
<p class="calibre1">Assert.assertEquals(500, portfolio.value());</p>
<p class="calibre1">}</p>
<p class="calibre1">}</p>
<p class="calibre1">If a system is decoupled enough to be tested in this way, it will also be more flexible and promote more reuse. The lack of coupling means that the elements of our system are better isolated from each other and from change. This isolation makes it easier to understand each element of the system.</p>
<p class="calibre1">By minimizing coupling in this way, our classes adhere to another class design principle known as the Dependency Inversion Principle (DIP).5 In essence, the DIP says that our classes should depend upon abstractions, not on concrete details.</p>
<p class="calibre1">Instead of being dependent upon the implementation details of the TokyoStockExchange class, our Portfolio class is now dependent upon the StockExchange interface.</p>
<p class="calibre1">The StockExchange interface represents the abstract concept of asking for the current price of a symbol. This abstraction isolates all of the specific details of obtaining such a price, including from where that price is obtained.</p>
<p class="calibre1">5.</p>
<p class="calibre1">[PPP].</p>
<p class="calibre1"><a id="p182"></a><b class="calibre3">Bibliography</b></p>
<p class="calibre1">151</p>
<p class="calibre1"><a href="index_split_000.html#p13"><b class="calibre3">Bibliography</b></a></p>
<p class="calibre1"><b class="calibre3">[RDD]:  </b> <i class="calibre4">Object Design: Roles, Responsibilities, and Collaborations</i>, Rebecca Wirfs-Brock et al., Addison-Wesley, 2002.</p>
<p class="calibre1"><b class="calibre3">[PPP]:  </b> <i class="calibre4">Agile Software Development: Principles, Patterns, and Practices</i>, Robert C. Martin, Prentice Hall, 2002.</p>
<p class="calibre1"><b class="calibre3">[Knuth92]:  </b> <i class="calibre4">Literate Programming, </i> Donald E. Knuth, Center for the Study of language and Information, Leland Stanford Junior University, 1992.</p>
<p class="calibre1"><a id="p183"></a> <i class="calibre4">This page intentionally left blank </i></p>
<p class="calibre1"><a id="p184"></a><img src="index-184_1.png" alt="Image 38" class="calibre2"/></p>
<p class="calibre1"><a href="index_split_000.html#p13"><b class="calibre3">11</b></a></p>
<p class="calibre1"><a href="index_split_000.html#p13"><b class="calibre3">Systems</b></a></p>
<p class="calibre1">by Dr. Kevin Dean Wampler</p>
<p class="calibre1"><i class="calibre4">“Complexity kills. It sucks the life out of developers, </i></p>
<p class="calibre1"><i class="calibre4">it makes products difficult to plan, build, and test.” </i></p>
<p class="calibre1">—Ray Ozzie, CTO, Microsoft Corporation</p>
<p class="calibre1">153</p>
<p class="calibre1"><a id="p185"></a>154</p>
<div class="calibre6" id="calibre_pb_145"></div>
</body>
</html>
