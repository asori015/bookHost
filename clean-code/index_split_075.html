<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <title>index</title>
    <meta name="generator" content="pdftohtml 0.36"/>
    <meta name="date" content="2009-10-16T23:21:09+00:00"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="calibre">
<h2 title="Chapter 11: Systems, **Figure 11-1**" class="calibre5" id="calibre_pb_148">Chapter 11: Systems</h2>
<h3 class="sigilnotintoc"><b class="calibre7">Figure 11-1</b></h3>

<p class="calibre1">Separating construction in main()</p>
<p class="calibre1">LineItem instances to add to an Order. In this case we can use the ABSTRACT FACTORY2</p>
<p class="calibre1">pattern to give the application control of  <i class="calibre4">when </i> to build the LineItems, but keep the details of that construction separate from the application code. (See Figure 11-2.) <b class="calibre3">Figure 11-2</b></p>
<p class="calibre1">Separation construction with factory</p>
<p class="calibre1">Again notice that all the dependencies point from main toward the OrderProcessing application. This means that the application is decoupled from the details of how to build a LineItem. That capability is held in the LineItemFactoryImplementation, which is on the main side of the line. And yet the application is in complete control of when the LineItem instances get built and can even provide application-specific constructor arguments.</p>
<p class="calibre1">2.</p>
<p class="calibre1">[GOF].</p>
<p class="calibre1"><a id="p188"></a><b class="calibre3">Scaling Up</b></p>
<p class="calibre1">157</p>
<p class="calibre1"><a href="index_split_000.html#p13"><b class="calibre3">Dependency Injection</b></a></p>
<p class="calibre1">A powerful mechanism for separating construction from use is  <i class="calibre4">Dependency Injection </i>(DI), the application of  <i class="calibre4">Inversion of Control </i>(IoC) to dependency management.3 Inversion of Control moves secondary responsibilities from an object to other objects that are dedicated to the purpose, thereby supporting the  <i class="calibre4">Single Responsibility Principle. </i> In the context of dependency management, an object should not take responsibility for instantiating dependencies itself. Instead, it should pass this responsibility to another “authoritative” mechanism, thereby inverting the control. Because setup is a global concern, this authoritative mechanism will usually be either the “main” routine or a special-purpose  <i class="calibre4">container. </i></p>
<p class="calibre1">JNDI lookups are a “partial” implementation of DI, where an object asks a directory server to provide a “service” matching a particular name.</p>
<p class="calibre1">MyService myService = (MyService)(jndiContext.lookup(“NameOfMyService”)); The invoking object doesn’t control what kind of object is actually returned (as long it implements the appropriate interface, of course), but the invoking object still actively resolves the dependency.</p>
<p class="calibre1">True Dependency Injection goes one step further. The class takes no direct steps to resolve its dependencies; it is completely passive. Instead, it provides setter methods or constructor arguments (or both) that are used to  <i class="calibre4">inject </i> the dependencies. During the construction process, the DI container instantiates the required objects (usually on demand) and uses the constructor arguments or setter methods provided to wire together the dependencies. Which dependent objects are actually used is specified through a configuration file or programmatically in a special-purpose construction module.</p>
<p class="calibre1">The Spring Framework provides the best known DI container for Java.4 You define which objects to wire together in an XML configuration file, then you ask for particular objects by name in Java code. We will look at an example shortly.</p>
<p class="calibre1">But what about the virtues of LAZY-INITIALIZATION? This idiom is still sometimes useful with DI. First, most DI containers won’t construct an object until needed. Second, many of these containers provide mechanisms for invoking factories or for constructing proxies, which could be used for LAZY-EVALUATION and similar  <i class="calibre4">optimizations. </i> 5</p>
<p class="calibre1"><a href="index_split_000.html#p13"><b class="calibre3">Scaling Up</b></a></p>
<p class="calibre1">Cities grow from towns, which grow from settlements. At first the roads are narrow and practically nonexistent, then they are paved, then widened over time. Small buildings and 3.</p>
<p class="calibre1">See, for example, [Fowler].</p>
<p class="calibre1">4.</p>
<p class="calibre1">See [Spring]. There is also a Spring.NET framework.</p>
<p class="calibre1">5.</p>
<p class="calibre1">Don’t forget that lazy instantiation/evaluation is just an optimization and perhaps premature!</p>
<p class="calibre1"><a id="p189"></a>158</p>
<div class="calibre6" id="calibre_pb_149"></div>
</body>
</html>
