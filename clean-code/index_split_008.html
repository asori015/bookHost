<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <title>index</title>
    <meta name="generator" content="pdftohtml 0.36"/>
    <meta name="date" content="2009-10-16T23:21:09+00:00"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="calibre">
<h2 class="calibre5" id="calibre_pb_14">Chapter 1: Clean Code</h2>
<p class="calibre1"><i class="calibre4">Ooops, he’s erasing what he typed! </i></p>
<p class="calibre1"><i class="calibre4">He types it again. </i></p>
<p class="calibre1"><i class="calibre4">He erases it again! </i></p>
<p class="calibre1"><i class="calibre4">He types half of something else but then erases that! </i></p>
<p class="calibre1"><i class="calibre4">He scrolls down to another function that calls the function he’s changing to see how it is</i> <i class="calibre4">called. </i></p>
<p class="calibre1"><i class="calibre4">He scrolls back up and types the same code he just erased. </i></p>
<p class="calibre1"><i class="calibre4">He pauses. </i></p>
<p class="calibre1"><i class="calibre4">He erases that code again! </i></p>
<p class="calibre1"><i class="calibre4">He pops up another window and looks at a subclass. Is that function overridden? </i></p>
<p class="calibre1">. . .</p>
<p class="calibre1">You get the drift. Indeed, the ratio of time spent reading vs. writing is well over 10:1.</p>
<p class="calibre1">We are  <i class="calibre4">constantly</i> reading old code as part of the effort to write new code.</p>
<p class="calibre1">Because this ratio is so high, we want the reading of code to be easy, even if it makes the writing harder. Of course there’s no way to write code without reading it, so  <i class="calibre4">making it</i> <i class="calibre4">easy to read actually makes it easier to write</i>.</p>
<p class="calibre1">There is no escape from this logic. You cannot write code if you cannot read the surrounding code. The code you are trying to write today will be hard or easy to write depending on how hard or easy the surrounding code is to read. So if you want to go fast, if you want to get done quickly, if you want your code to be easy to write, make it easy to read.</p>
<p class="calibre1"><a href="index_split_000.html#p8"><b class="calibre3">The Boy Scout Rule</b></a></p>
<p class="calibre1">It’s not enough to write the code well. The code has to be  <i class="calibre4">kept clean </i> over time. We’ve all seen code rot and degrade as time passes. So we must take an active role in preventing this degradation.</p>
<p class="calibre1">The Boy Scouts of America have a simple rule that we can apply to our profession.</p>
<p class="calibre1"><i class="calibre4">Leave the campground cleaner than you found it.5</i></p>
<p class="calibre1">If we all checked-in our code a little cleaner than when we checked it out, the code simply could not rot. The cleanup doesn’t have to be something big. Change one variable name for the better, break up one function that’s a little too large, eliminate one small bit of duplication, clean up one composite if statement.</p>
<p class="calibre1">Can you imagine working on a project where the code  <i class="calibre4">simply got better </i> as time passed? Do you believe that any other option is professional? Indeed, isn’t continuous improvement an intrinsic part of professionalism?</p>
<p class="calibre1">5.</p>
<p class="calibre1">This was adapted from Robert Stephenson Smyth Baden-Powell’s farewell message to the Scouts: “Try and leave this world a little better than you found it . . .”</p>
<p class="calibre1"><a id="p46"></a><b class="calibre3">Bibliography</b></p>
<p class="calibre1">15</p>
<p class="calibre1"><a href="index_split_000.html#p8"><b class="calibre3">Prequel and Principles</b></a></p>
<p class="calibre1">In many ways this book is a “prequel” to a book I wrote in 2002 entitled  <i class="calibre4">Agile Software</i> <i class="calibre4">Development: Principles, Patterns, and Practices </i>(PPP). The PPP book concerns itself with the principles of object-oriented design, and many of the practices used by professional developers. If you have not read PPP, then you may find that it continues the story told by this book. If you have already read it, then you’ll find many of the sentiments of that book echoed in this one at the level of code.</p>
<p class="calibre1">In this book you will find sporadic references to various principles of design. These include the Single Responsibility Principle (SRP), the Open Closed Principle (OCP), and the Dependency Inversion Principle (DIP) among others. These principles are described in depth in PPP.</p>
<p class="calibre1"><a href="index_split_000.html#p8"><b class="calibre3">Conclusion</b></a></p>
<p class="calibre1">Books on art don’t promise to make you an artist. All they can do is give you some of the tools, techniques, and thought processes that other artists have used. So too this book cannot promise to make you a good programmer. It cannot promise to give you “code-sense.”</p>
<p class="calibre1">All it can do is show you the thought processes of good programmers and the tricks, techniques, and tools that they use.</p>
<p class="calibre1">Just like a book on art, this book will be full of details. There will be lots of code.</p>
<p class="calibre1">You’ll see good code and you’ll see bad code. You’ll see bad code transformed into good code. You’ll see lists of heuristics, disciplines, and techniques. You’ll see example after example. After that, it’s up to you.</p>
<p class="calibre1">Remember the old joke about the concert violinist who got lost on his way to a performance? He stopped an old man on the corner and asked him how to get to Carnegie Hall.</p>
<p class="calibre1">The old man looked at the violinist and the violin tucked under his arm, and said: “Practice, son. Practice!”</p>
<p class="calibre1"><a href="index_split_000.html#p8"><b class="calibre3">Bibliography</b></a></p>
<p class="calibre1"><b class="calibre3">[Beck07]:  </b> <i class="calibre4">Implementation Patterns</i>, Kent Beck, Addison-Wesley, 2007.</p>
<p class="calibre1"><b class="calibre3">[Knuth92]:  </b> <i class="calibre4">Literate Programming</i>, Donald E. Knuth, Center for the Study of Language and Information, Leland Stanford Junior University, 1992.</p>
<p class="calibre1"><a id="p47"></a> <i class="calibre4">This page intentionally left blank </i></p>
<p class="calibre1"><a id="p48"></a><img src="index-48_1.png" alt="Image 16" class="calibre2"/></p>
<p class="calibre1"><a href="index_split_000.html#p8"><b class="calibre3">2</b></a></p>
<p class="calibre1"><a href="index_split_000.html#p8"><b class="calibre3">Meaningful Names</b></a></p>
<p class="calibre1">by Tim Ottinger</p>
<p class="calibre1"><a href="index_split_000.html#p8"><b class="calibre3">Introduction</b></a></p>
<p class="calibre1">Names are everywhere in software. We name our variables, our functions, our arguments, classes, and packages. We name our source files and the directories that contain them. We name our jar files and war files and ear files. We name and name and name. Because we do 17</p>
<p class="calibre1"><a id="p49"></a>18</p>
<div class="calibre6" id="calibre_pb_15"></div>
</body>
</html>
